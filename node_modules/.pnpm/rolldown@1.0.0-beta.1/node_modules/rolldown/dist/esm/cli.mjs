import { LogLevelOptionSchema, LogLevelSchema, LogLevelWithErrorSchema, RollupLogSchema, RollupLogWithStringSchema, TreeshakingOptionsSchema, arraify, description, rolldown, version, watch } from "../shared/src-Bb3zZkPW.mjs";
import { createConsola } from "../shared/consola_36c0034f-D9ce-831.mjs";
import fs from "node:fs";
import { ZodFirstPartyTypeKind, z } from "zod";
import path from "node:path";
import process$1, { env } from "node:process";
import { performance } from "node:perf_hooks";
import * as tty from "tty";
import { parseArgs } from "node:util";
import { pathToFileURL } from "node:url";

//#region ../../node_modules/.pnpm/signal-exit@4.1.0/node_modules/signal-exit/dist/mjs/signals.js
const signals = [];
signals.push("SIGHUP", "SIGINT", "SIGTERM");
if (process.platform !== "win32") signals.push(
	"SIGALRM",
	"SIGABRT",
	"SIGVTALRM",
	"SIGXCPU",
	"SIGXFSZ",
	"SIGUSR2",
	"SIGTRAP",
	"SIGSYS",
	"SIGQUIT",
	"SIGIOT"
	// should detect profiler and enable/disable accordingly.
	// see #21
	// 'SIGPROF'
);
if (process.platform === "linux") signals.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT");

//#endregion
//#region ../../node_modules/.pnpm/signal-exit@4.1.0/node_modules/signal-exit/dist/mjs/index.js
const processOk = (process$3) => !!process$3 && typeof process$3 === "object" && typeof process$3.removeListener === "function" && typeof process$3.emit === "function" && typeof process$3.reallyExit === "function" && typeof process$3.listeners === "function" && typeof process$3.kill === "function" && typeof process$3.pid === "number" && typeof process$3.on === "function";
const kExitEmitter = Symbol.for("signal-exit emitter");
const global = globalThis;
const ObjectDefineProperty = Object.defineProperty.bind(Object);
var Emitter = class {
	emitted = {
		afterExit: false,
		exit: false
	};
	listeners = {
		afterExit: [],
		exit: []
	};
	count = 0;
	id = Math.random();
	constructor() {
		if (global[kExitEmitter]) return global[kExitEmitter];
		ObjectDefineProperty(global, kExitEmitter, {
			value: this,
			writable: false,
			enumerable: false,
			configurable: false
		});
	}
	on(ev, fn) {
		this.listeners[ev].push(fn);
	}
	removeListener(ev, fn) {
		const list = this.listeners[ev];
		const i = list.indexOf(fn);
		if (i === -1) return;
		if (i === 0 && list.length === 1) list.length = 0;
else list.splice(i, 1);
	}
	emit(ev, code, signal) {
		if (this.emitted[ev]) return false;
		this.emitted[ev] = true;
		let ret = false;
		for (const fn of this.listeners[ev]) ret = fn(code, signal) === true || ret;
		if (ev === "exit") ret = this.emit("afterExit", code, signal) || ret;
		return ret;
	}
};
var SignalExitBase = class {};
const signalExitWrap = (handler) => {
	return {
		onExit(cb, opts) {
			return handler.onExit(cb, opts);
		},
		load() {
			return handler.load();
		},
		unload() {
			return handler.unload();
		}
	};
};
var SignalExitFallback = class extends SignalExitBase {
	onExit() {
		return () => {};
	}
	load() {}
	unload() {}
};
var SignalExit = class extends SignalExitBase {
	#hupSig = process$2.platform === "win32" ? "SIGINT" : "SIGHUP";
	#emitter = new Emitter();
	#process;
	#originalProcessEmit;
	#originalProcessReallyExit;
	#sigListeners = {};
	#loaded = false;
	constructor(process$3) {
		super();
		this.#process = process$3;
		this.#sigListeners = {};
		for (const sig of signals) this.#sigListeners[sig] = () => {
			const listeners = this.#process.listeners(sig);
			let { count } = this.#emitter;
			const p = process$3;
			if (typeof p.__signal_exit_emitter__ === "object" && typeof p.__signal_exit_emitter__.count === "number") count += p.__signal_exit_emitter__.count;
			if (listeners.length === count) {
				this.unload();
				const ret = this.#emitter.emit("exit", null, sig);
				const s = sig === "SIGHUP" ? this.#hupSig : sig;
				if (!ret) process$3.kill(process$3.pid, s);
			}
		};
		this.#originalProcessReallyExit = process$3.reallyExit;
		this.#originalProcessEmit = process$3.emit;
	}
	onExit(cb, opts) {
		if (!processOk(this.#process)) return () => {};
		if (this.#loaded === false) this.load();
		const ev = opts?.alwaysLast ? "afterExit" : "exit";
		this.#emitter.on(ev, cb);
		return () => {
			this.#emitter.removeListener(ev, cb);
			if (this.#emitter.listeners["exit"].length === 0 && this.#emitter.listeners["afterExit"].length === 0) this.unload();
		};
	}
	load() {
		if (this.#loaded) return;
		this.#loaded = true;
		this.#emitter.count += 1;
		for (const sig of signals) try {
			const fn = this.#sigListeners[sig];
			if (fn) this.#process.on(sig, fn);
		} catch (_) {}
		this.#process.emit = (ev, ...a) => {
			return this.#processEmit(ev, ...a);
		};
		this.#process.reallyExit = (code) => {
			return this.#processReallyExit(code);
		};
	}
	unload() {
		if (!this.#loaded) return;
		this.#loaded = false;
		signals.forEach((sig) => {
			const listener = this.#sigListeners[sig];
			if (!listener) throw new Error("Listener not defined for signal: " + sig);
			try {
				this.#process.removeListener(sig, listener);
			} catch (_) {}
		});
		this.#process.emit = this.#originalProcessEmit;
		this.#process.reallyExit = this.#originalProcessReallyExit;
		this.#emitter.count -= 1;
	}
	#processReallyExit(code) {
		if (!processOk(this.#process)) return 0;
		this.#process.exitCode = code || 0;
		this.#emitter.emit("exit", this.#process.exitCode, null);
		return this.#originalProcessReallyExit.call(this.#process, this.#process.exitCode);
	}
	#processEmit(ev, ...args) {
		const og = this.#originalProcessEmit;
		if (ev === "exit" && processOk(this.#process)) {
			if (typeof args[0] === "number") this.#process.exitCode = args[0];
			const ret = og.call(this.#process, ev, ...args);
			this.#emitter.emit("exit", this.#process.exitCode, null);
			return ret;
		} else return og.call(this.#process, ev, ...args);
	}
};
const process$2 = globalThis.process;
const { onExit, load, unload } = signalExitWrap(processOk(process$2) ? new SignalExit(process$2) : new SignalExitFallback());

//#endregion
//#region ../../node_modules/.pnpm/colorette@2.0.20/node_modules/colorette/index.js
const { env: env$1 = {}, argv = [], platform = "" } = typeof process === "undefined" ? {} : process;
const isDisabled = "NO_COLOR" in env$1 || argv.includes("--no-color");
const isForced = "FORCE_COLOR" in env$1 || argv.includes("--color");
const isWindows = platform === "win32";
const isDumbTerminal = env$1.TERM === "dumb";
const isCompatibleTerminal = tty && tty.isatty && tty.isatty(1) && env$1.TERM && !isDumbTerminal;
const isCI = "CI" in env$1 && ("GITHUB_ACTIONS" in env$1 || "GITLAB_CI" in env$1 || "CIRCLECI" in env$1);
const isColorSupported = !isDisabled && (isForced || isWindows && !isDumbTerminal || isCompatibleTerminal || isCI);
const replaceClose = (index, string, close, replace, head = string.substring(0, index) + replace, tail = string.substring(index + close.length), next = tail.indexOf(close)) => head + (next < 0 ? tail : replaceClose(next, tail, close, replace));
const clearBleed = (index, string, open, close, replace) => index < 0 ? open + string + close : open + replaceClose(index, string, close, replace) + close;
const filterEmpty = (open, close, replace = open, at = open.length + 1) => (string) => string || !(string === "" || string === undefined) ? clearBleed(("" + string).indexOf(close, at), string, open, close, replace) : "";
const init = (open, close, replace) => filterEmpty(`\x1b[${open}m`, `\x1b[${close}m`, replace);
const colors$1 = {
	reset: init(0, 0),
	bold: init(1, 22, "\x1B[22m\x1B[1m"),
	dim: init(2, 22, "\x1B[22m\x1B[2m"),
	italic: init(3, 23),
	underline: init(4, 24),
	inverse: init(7, 27),
	hidden: init(8, 28),
	strikethrough: init(9, 29),
	black: init(30, 39),
	red: init(31, 39),
	green: init(32, 39),
	yellow: init(33, 39),
	blue: init(34, 39),
	magenta: init(35, 39),
	cyan: init(36, 39),
	white: init(37, 39),
	gray: init(90, 39),
	bgBlack: init(40, 49),
	bgRed: init(41, 49),
	bgGreen: init(42, 49),
	bgYellow: init(43, 49),
	bgBlue: init(44, 49),
	bgMagenta: init(45, 49),
	bgCyan: init(46, 49),
	bgWhite: init(47, 49),
	blackBright: init(90, 39),
	redBright: init(91, 39),
	greenBright: init(92, 39),
	yellowBright: init(93, 39),
	blueBright: init(94, 39),
	magentaBright: init(95, 39),
	cyanBright: init(96, 39),
	whiteBright: init(97, 39),
	bgBlackBright: init(100, 49),
	bgRedBright: init(101, 49),
	bgGreenBright: init(102, 49),
	bgYellowBright: init(103, 49),
	bgBlueBright: init(104, 49),
	bgMagentaBright: init(105, 49),
	bgCyanBright: init(106, 49),
	bgWhiteBright: init(107, 49)
};
const createColors = ({ useColor = isColorSupported } = {}) => useColor ? colors$1 : Object.keys(colors$1).reduce((colors$2, key) => ({
	...colors$2,
	[key]: String
}), {});
const { reset, bold: bold$1, dim: dim$1, italic, underline: underline$1, inverse, hidden, strikethrough, black, red: red$1, green: green$1, yellow: yellow$1, blue, magenta, cyan: cyan$1, white, gray: gray$1, bgBlack, bgRed, bgGreen, bgYellow, bgBlue, bgMagenta, bgCyan, bgWhite, blackBright, redBright, greenBright, yellowBright, blueBright, magentaBright, cyanBright, whiteBright, bgBlackBright, bgRedBright, bgGreenBright, bgYellowBright, bgBlueBright, bgMagentaBright, bgCyanBright, bgWhiteBright } = createColors();

//#endregion
//#region src/cli/colors.ts
const { bold, cyan, dim, gray, green, red, underline, yellow } = createColors({ useColor: env.FORCE_COLOR !== "0" && !env.NO_COLOR });
const colors = {
	bold,
	cyan,
	dim,
	gray,
	green,
	red,
	underline,
	yellow
};

//#endregion
//#region src/cli/logger.ts
const logger = process.env.ROLLDOWN_TEST ? createTestingLogger() : createConsola({ formatOptions: { date: false } });
function createTestingLogger() {
	const types = [
		"silent",
		"fatal",
		"error",
		"warn",
		"log",
		"info",
		"success",
		"fail",
		"ready",
		"start",
		"box",
		"debug",
		"trace",
		"verbose"
	];
	const ret = Object.create(null);
	for (const type of types) ret[type] = console.log;
	return ret;
}

//#endregion
//#region src/cli/load-config.ts
async function loadTsConfig(configFile) {
	const file = await bundleTsConfig(configFile);
	try {
		return (await import(pathToFileURL(file).href)).default;
	} finally {
		fs.unlink(file, () => {});
	}
}
async function bundleTsConfig(configFile) {
	const dirnameVarName = "injected_original_dirname";
	const filenameVarName = "injected_original_filename";
	const importMetaUrlVarName = "injected_original_import_meta_url";
	const bundle = await rolldown({
		input: configFile,
		platform: "node",
		resolve: { mainFields: ["main"] },
		define: {
			__dirname: dirnameVarName,
			__filename: filenameVarName,
			"import.meta.url": importMetaUrlVarName,
			"import.meta.dirname": dirnameVarName,
			"import.meta.filename": filenameVarName
		},
		treeshake: false,
		external: [/^[\w@][^:]/],
		plugins: [{
			name: "inject-file-scope-variables",
			transform: {
				filter: { id: /\.[cm]?[jt]s$/ },
				async handler(code, id) {
					const injectValues = `const ${dirnameVarName} = ${JSON.stringify(path.dirname(id))};` + `const ${filenameVarName} = ${JSON.stringify(id)};` + `const ${importMetaUrlVarName} = ${JSON.stringify(pathToFileURL(id).href)};`;
					return {
						code: injectValues + code,
						map: null
					};
				}
			}
		}]
	});
	const result = await bundle.write({
		dir: path.dirname(configFile),
		format: "esm",
		sourcemap: "inline",
		entryFileNames: "rolldown.config.[hash].js"
	});
	return result.output.find((chunk) => chunk.type === "chunk" && chunk.isEntry).fileName;
}
const SUPPORTED_JS_CONFIG_FORMATS = [
	".js",
	".mjs",
	".cjs"
];
const SUPPORTED_TS_CONFIG_FORMATS = [
	".ts",
	".mts",
	".cts"
];
const SUPPORTED_CONFIG_FORMATS = [...SUPPORTED_JS_CONFIG_FORMATS, ...SUPPORTED_TS_CONFIG_FORMATS];
async function loadConfig(configPath) {
	const ext = path.extname(configPath);
	try {
		if (SUPPORTED_JS_CONFIG_FORMATS.includes(ext) || process.env.NODE_OPTIONS?.includes("--import=tsx") && SUPPORTED_TS_CONFIG_FORMATS.includes(ext)) return (await import(pathToFileURL(configPath).href)).default;
else if (SUPPORTED_TS_CONFIG_FORMATS.includes(ext)) return await loadTsConfig(configPath);
else throw new Error(`Unsupported config format. Expected: \`${SUPPORTED_CONFIG_FORMATS.join(",")}\` but got \`${ext}\``);
	} catch (err) {
		throw new Error("Error happened while loading config.", { cause: err });
	}
}

//#endregion
//#region src/cli/commands/bundle.ts
async function bundleWithConfig(configPath, cliOptions) {
	const config = await loadConfig(configPath);
	if (!config) {
		logger.error(`No configuration found at ${config}`);
		process.exit(1);
	}
	if (cliOptions.watch) await watchInner(config, cliOptions);
else await bundleInner(config, cliOptions);
}
async function bundleWithCliOptions(cliOptions) {
	if (cliOptions.output.dir || cliOptions.output.file) {
		const operation = cliOptions.watch ? watchInner : bundleInner;
		await operation({}, cliOptions);
		return;
	}
	if (cliOptions.watch) {
		logger.error("You must specify `output.dir` to use watch mode");
		process.exit(1);
	}
	const build = await rolldown(cliOptions.input);
	try {
		const { output: outputs } = await build.generate(cliOptions.output);
		if (outputs.length === 0) {
			logger.error("No output generated");
			process.exit(1);
		}
		for (const file of outputs) {
			if (outputs.length > 1) logger.log(`\n${colors.cyan(colors.bold(`|→ ${file.fileName}:`))}\n`);
			console.log(file.type === "asset" ? file.source : file.code);
		}
	} finally {
		await build.close();
	}
}
async function watchInner(config, cliOptions) {
	let normalizedConfig = arraify(config).map((option) => {
		return {
			...option,
			...cliOptions.input,
			output: arraify(option.output || {}).map((output) => {
				return {
					...output,
					...cliOptions.output
				};
			})
		};
	});
	const watcher = await watch(normalizedConfig);
	onExit((code) => {
		Promise.resolve(watcher.close()).finally(() => {
			process.exit(typeof code === "number" ? code : 0);
		});
		return true;
	});
	const changedFile = [];
	watcher.on("change", (id, event) => {
		if (event.event === "update") changedFile.push(id);
	});
	watcher.on("event", (event) => {
		switch (event.code) {
			case "BUNDLE_START":
				if (changedFile.length > 0) logger.log(`Found ${colors.bold(changedFile.map(relativeId).join(", "))} changed, rebuilding...`);
				changedFile.length = 0;
				break;
			case "BUNDLE_END":
				logger.success(`Rebuilt ${colors.bold(relativeId(event.output[0]))} in ${colors.bold(ms(event.duration))}.`);
				break;
			case "ERROR":
				logger.error(event.error);
				break;
			default: break;
		}
	});
	logger.log(`Waiting for changes...`);
}
async function bundleInner(config, cliOptions) {
	const startTime = performance.now();
	const result = [];
	const configList = arraify(config);
	for (const config$1 of configList) {
		const outputList = arraify(config$1.output || {});
		for (const output of outputList) {
			const build = await rolldown({
				...config$1,
				...cliOptions.input
			});
			try {
				result.push(await build.write({
					...output,
					...cliOptions.output
				}));
			} finally {
				await build.close();
			}
		}
	}
	result.forEach(printBundleOutputPretty);
	logger.log(``);
	const endTime = performance.now();
	const duration = endTime - startTime;
	logger.success(`Finished in ${colors.bold(ms(duration))}`);
}
function printBundleOutputPretty(output) {
	const outputEntries = collectOutputEntries(output.output);
	const outputLayoutSizes = collectOutputLayoutAdjustmentSizes(outputEntries);
	printOutputEntries(outputEntries, outputLayoutSizes, "<DIR>");
}
function collectOutputEntries(output) {
	return output.map((chunk) => ({
		type: chunk.type,
		fileName: chunk.fileName,
		size: chunk.type === "chunk" ? chunk.code.length : chunk.source.length
	}));
}
function collectOutputLayoutAdjustmentSizes(entries) {
	let longest = 0;
	let biggestSize = 0;
	for (const entry of entries) {
		if (entry.fileName.length > longest) longest = entry.fileName.length;
		if (entry.size > biggestSize) biggestSize = entry.size;
	}
	const sizePad = displaySize(biggestSize).length;
	return {
		longest,
		biggestSize,
		sizePad
	};
}
const numberFormatter = new Intl.NumberFormat("en", {
	maximumFractionDigits: 2,
	minimumFractionDigits: 2
});
function displaySize(bytes) {
	return `${numberFormatter.format(bytes / 1e3)} kB`;
}
const CHUNK_GROUPS = [{
	type: "asset",
	color: "green"
}, {
	type: "chunk",
	color: "cyan"
}];
function printOutputEntries(entries, sizeAdjustment, distPath) {
	for (const group of CHUNK_GROUPS) {
		const filtered = entries.filter((e) => e.type === group.type);
		if (!filtered.length) continue;
		for (const entry of filtered.sort((a, z$1) => a.size - z$1.size)) {
			let log = colors.dim(withTrailingSlash(distPath));
			log += colors[group.color](entry.fileName.padEnd(sizeAdjustment.longest + 2));
			log += colors.dim(entry.type);
			log += colors.dim(` │ size: ${displaySize(entry.size).padStart(sizeAdjustment.sizePad)}`);
			logger.log(log);
		}
	}
}
function withTrailingSlash(path$1) {
	if (path$1[path$1.length - 1] !== "/") return `${path$1}/`;
	return path$1;
}
function ms(duration) {
	return duration < 1e3 ? `${duration.toFixed(2)} ms` : `${(duration / 1e3).toFixed(2)} s`;
}
function relativeId(id) {
	if (!path.isAbsolute(id)) return id;
	return path.relative(path.resolve(), id);
}

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/Options.js
const ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
const defaultOptions = {
	name: undefined,
	$refStrategy: "root",
	basePath: ["#"],
	effectStrategy: "input",
	pipeStrategy: "all",
	dateStrategy: "format:date-time",
	mapStrategy: "entries",
	removeAdditionalStrategy: "passthrough",
	definitionPath: "definitions",
	target: "jsonSchema7",
	strictUnions: false,
	definitions: {},
	errorMessages: false,
	markdownDescription: false,
	patternStrategy: "escape",
	applyRegexFlags: false,
	emailStrategy: "format:email",
	base64Strategy: "contentEncoding:base64",
	nameStrategy: "ref"
};
const getDefaultOptions = (options$1) => typeof options$1 === "string" ? {
	...defaultOptions,
	name: options$1
} : {
	...defaultOptions,
	...options$1
};

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/Refs.js
const getRefs = (options$1) => {
	const _options = getDefaultOptions(options$1);
	const currentPath = _options.name !== undefined ? [
		..._options.basePath,
		_options.definitionPath,
		_options.name
	] : _options.basePath;
	return {
		..._options,
		currentPath,
		propertyPath: undefined,
		seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [def._def, {
			def: def._def,
			path: [
				..._options.basePath,
				_options.definitionPath,
				name
			],
			jsonSchema: undefined
		}]))
	};
};

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/errorMessages.js
function addErrorMessage(res, key, errorMessage, refs) {
	if (!refs?.errorMessages) return;
	if (errorMessage) res.errorMessage = {
		...res.errorMessage,
		[key]: errorMessage
	};
}
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
	res[key] = value;
	addErrorMessage(res, key, errorMessage, refs);
}

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/any.js
function parseAnyDef() {
	return {};
}

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/array.js
function parseArrayDef(def, refs) {
	const res = { type: "array" };
	if (def.type?._def && def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) res.items = parseDef(def.type._def, {
		...refs,
		currentPath: [...refs.currentPath, "items"]
	});
	if (def.minLength) setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
	if (def.maxLength) setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
	if (def.exactLength) {
		setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
		setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
	}
	return res;
}

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js
function parseBigintDef(def, refs) {
	const res = {
		type: "integer",
		format: "int64"
	};
	if (!def.checks) return res;
	for (const check of def.checks) switch (check.kind) {
		case "min":
			if (refs.target === "jsonSchema7") if (check.inclusive) setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
else setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
else {
				if (!check.inclusive) res.exclusiveMinimum = true;
				setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
			}
			break;
		case "max":
			if (refs.target === "jsonSchema7") if (check.inclusive) setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
else setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
else {
				if (!check.inclusive) res.exclusiveMaximum = true;
				setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
			}
			break;
		case "multipleOf":
			setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
			break;
	}
	return res;
}

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js
function parseBooleanDef() {
	return { type: "boolean" };
}

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/branded.js
function parseBrandedDef(_def, refs) {
	return parseDef(_def.type._def, refs);
}

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/catch.js
const parseCatchDef = (def, refs) => {
	return parseDef(def.innerType._def, refs);
};

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/date.js
function parseDateDef(def, refs, overrideDateStrategy) {
	const strategy = overrideDateStrategy ?? refs.dateStrategy;
	if (Array.isArray(strategy)) return { anyOf: strategy.map((item, i) => parseDateDef(def, refs, item)) };
	switch (strategy) {
		case "string":
		case "format:date-time": return {
			type: "string",
			format: "date-time"
		};
		case "format:date": return {
			type: "string",
			format: "date"
		};
		case "integer": return integerDateParser(def, refs);
	}
}
const integerDateParser = (def, refs) => {
	const res = {
		type: "integer",
		format: "unix-time"
	};
	if (refs.target === "openApi3") return res;
	for (const check of def.checks) switch (check.kind) {
		case "min":
			setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
			break;
		case "max":
			setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
			break;
	}
	return res;
};

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/default.js
function parseDefaultDef(_def, refs) {
	return {
		...parseDef(_def.innerType._def, refs),
		default: _def.defaultValue()
	};
}

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/effects.js
function parseEffectsDef(_def, refs) {
	return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : {};
}

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/enum.js
function parseEnumDef(def) {
	return {
		type: "string",
		enum: def.values
	};
}

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js
const isJsonSchema7AllOfType = (type) => {
	if ("type" in type && type.type === "string") return false;
	return "allOf" in type;
};
function parseIntersectionDef(def, refs) {
	const allOf = [parseDef(def.left._def, {
		...refs,
		currentPath: [
			...refs.currentPath,
			"allOf",
			"0"
		]
	}), parseDef(def.right._def, {
		...refs,
		currentPath: [
			...refs.currentPath,
			"allOf",
			"1"
		]
	})].filter((x) => !!x);
	let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : undefined;
	const mergedAllOf = [];
	allOf.forEach((schema$1) => {
		if (isJsonSchema7AllOfType(schema$1)) {
			mergedAllOf.push(...schema$1.allOf);
			if (schema$1.unevaluatedProperties === undefined) unevaluatedProperties = undefined;
		} else {
			let nestedSchema = schema$1;
			if ("additionalProperties" in schema$1 && schema$1.additionalProperties === false) {
				const { additionalProperties,...rest } = schema$1;
				nestedSchema = rest;
			} else unevaluatedProperties = undefined;
			mergedAllOf.push(nestedSchema);
		}
	});
	return mergedAllOf.length ? {
		allOf: mergedAllOf,
		...unevaluatedProperties
	} : undefined;
}

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/literal.js
function parseLiteralDef(def, refs) {
	const parsedType = typeof def.value;
	if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") return { type: Array.isArray(def.value) ? "array" : "object" };
	if (refs.target === "openApi3") return {
		type: parsedType === "bigint" ? "integer" : parsedType,
		enum: [def.value]
	};
	return {
		type: parsedType === "bigint" ? "integer" : parsedType,
		const: def.value
	};
}

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/string.js
let emojiRegex;
const zodPatterns = {
	cuid: /^[cC][^\s-]{8,}$/,
	cuid2: /^[0-9a-z]+$/,
	ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
	email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
	emoji: () => {
		if (emojiRegex === undefined) emojiRegex = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
		return emojiRegex;
	},
	uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
	ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
	ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
	base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
	nanoid: /^[a-zA-Z0-9_-]{21}$/
};
function parseStringDef(def, refs) {
	const res = { type: "string" };
	function processPattern(value) {
		return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(value) : value;
	}
	if (def.checks) for (const check of def.checks) switch (check.kind) {
		case "min":
			setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
			break;
		case "max":
			setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
			break;
		case "email":
			switch (refs.emailStrategy) {
				case "format:email":
					addFormat(res, "email", check.message, refs);
					break;
				case "format:idn-email":
					addFormat(res, "idn-email", check.message, refs);
					break;
				case "pattern:zod":
					addPattern(res, zodPatterns.email, check.message, refs);
					break;
			}
			break;
		case "url":
			addFormat(res, "uri", check.message, refs);
			break;
		case "uuid":
			addFormat(res, "uuid", check.message, refs);
			break;
		case "regex":
			addPattern(res, check.regex, check.message, refs);
			break;
		case "cuid":
			addPattern(res, zodPatterns.cuid, check.message, refs);
			break;
		case "cuid2":
			addPattern(res, zodPatterns.cuid2, check.message, refs);
			break;
		case "startsWith":
			addPattern(res, RegExp(`^${processPattern(check.value)}`), check.message, refs);
			break;
		case "endsWith":
			addPattern(res, RegExp(`${processPattern(check.value)}$`), check.message, refs);
			break;
		case "datetime":
			addFormat(res, "date-time", check.message, refs);
			break;
		case "date":
			addFormat(res, "date", check.message, refs);
			break;
		case "time":
			addFormat(res, "time", check.message, refs);
			break;
		case "duration":
			addFormat(res, "duration", check.message, refs);
			break;
		case "length":
			setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
			setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
			break;
		case "includes": {
			addPattern(res, RegExp(processPattern(check.value)), check.message, refs);
			break;
		}
		case "ip": {
			if (check.version !== "v6") addFormat(res, "ipv4", check.message, refs);
			if (check.version !== "v4") addFormat(res, "ipv6", check.message, refs);
			break;
		}
		case "emoji":
			addPattern(res, zodPatterns.emoji, check.message, refs);
			break;
		case "ulid": {
			addPattern(res, zodPatterns.ulid, check.message, refs);
			break;
		}
		case "base64": {
			switch (refs.base64Strategy) {
				case "format:binary": {
					addFormat(res, "binary", check.message, refs);
					break;
				}
				case "contentEncoding:base64": {
					setResponseValueAndErrors(res, "contentEncoding", "base64", check.message, refs);
					break;
				}
				case "pattern:zod": {
					addPattern(res, zodPatterns.base64, check.message, refs);
					break;
				}
			}
			break;
		}
		case "nanoid": addPattern(res, zodPatterns.nanoid, check.message, refs);
		case "toLowerCase":
		case "toUpperCase":
		case "trim": break;
		default: ((_) => {})(check);
	}
	return res;
}
const escapeNonAlphaNumeric = (value) => Array.from(value).map((c) => /[a-zA-Z0-9]/.test(c) ? c : `\\${c}`).join("");
const addFormat = (schema$1, value, message, refs) => {
	if (schema$1.format || schema$1.anyOf?.some((x) => x.format)) {
		if (!schema$1.anyOf) schema$1.anyOf = [];
		if (schema$1.format) {
			schema$1.anyOf.push({
				format: schema$1.format,
				...schema$1.errorMessage && refs.errorMessages && { errorMessage: { format: schema$1.errorMessage.format } }
			});
			delete schema$1.format;
			if (schema$1.errorMessage) {
				delete schema$1.errorMessage.format;
				if (Object.keys(schema$1.errorMessage).length === 0) delete schema$1.errorMessage;
			}
		}
		schema$1.anyOf.push({
			format: value,
			...message && refs.errorMessages && { errorMessage: { format: message } }
		});
	} else setResponseValueAndErrors(schema$1, "format", value, message, refs);
};
const addPattern = (schema$1, regex, message, refs) => {
	if (schema$1.pattern || schema$1.allOf?.some((x) => x.pattern)) {
		if (!schema$1.allOf) schema$1.allOf = [];
		if (schema$1.pattern) {
			schema$1.allOf.push({
				pattern: schema$1.pattern,
				...schema$1.errorMessage && refs.errorMessages && { errorMessage: { pattern: schema$1.errorMessage.pattern } }
			});
			delete schema$1.pattern;
			if (schema$1.errorMessage) {
				delete schema$1.errorMessage.pattern;
				if (Object.keys(schema$1.errorMessage).length === 0) delete schema$1.errorMessage;
			}
		}
		schema$1.allOf.push({
			pattern: processRegExp(regex, refs),
			...message && refs.errorMessages && { errorMessage: { pattern: message } }
		});
	} else setResponseValueAndErrors(schema$1, "pattern", processRegExp(regex, refs), message, refs);
};
const processRegExp = (regexOrFunction, refs) => {
	const regex = typeof regexOrFunction === "function" ? regexOrFunction() : regexOrFunction;
	if (!refs.applyRegexFlags || !regex.flags) return regex.source;
	const flags = {
		i: regex.flags.includes("i"),
		m: regex.flags.includes("m"),
		s: regex.flags.includes("s")
	};
	const source = flags.i ? regex.source.toLowerCase() : regex.source;
	let pattern = "";
	let isEscaped = false;
	let inCharGroup = false;
	let inCharRange = false;
	for (let i = 0; i < source.length; i++) {
		if (isEscaped) {
			pattern += source[i];
			isEscaped = false;
			continue;
		}
		if (flags.i) {
			if (inCharGroup) {
				if (source[i].match(/[a-z]/)) {
					if (inCharRange) {
						pattern += source[i];
						pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
						inCharRange = false;
					} else if (source[i + 1] === "-" && source[i + 2]?.match(/[a-z]/)) {
						pattern += source[i];
						inCharRange = true;
					} else pattern += `${source[i]}${source[i].toUpperCase()}`;
					continue;
				}
			} else if (source[i].match(/[a-z]/)) {
				pattern += `[${source[i]}${source[i].toUpperCase()}]`;
				continue;
			}
		}
		if (flags.m) {
			if (source[i] === "^") {
				pattern += `(^|(?<=[\r\n]))`;
				continue;
			} else if (source[i] === "$") {
				pattern += `($|(?=[\r\n]))`;
				continue;
			}
		}
		if (flags.s && source[i] === ".") {
			pattern += inCharGroup ? `${source[i]}\r\n` : `[${source[i]}\r\n]`;
			continue;
		}
		pattern += source[i];
		if (source[i] === "\\") isEscaped = true;
else if (inCharGroup && source[i] === "]") inCharGroup = false;
else if (!inCharGroup && source[i] === "[") inCharGroup = true;
	}
	try {
		const regexTest = new RegExp(pattern);
	} catch {
		console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
		return regex.source;
	}
	return pattern;
};

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/record.js
function parseRecordDef(def, refs) {
	if (refs.target === "openApi3" && def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) return {
		type: "object",
		required: def.keyType._def.values,
		properties: def.keyType._def.values.reduce((acc, key) => ({
			...acc,
			[key]: parseDef(def.valueType._def, {
				...refs,
				currentPath: [
					...refs.currentPath,
					"properties",
					key
				]
			}) ?? {}
		}), {}),
		additionalProperties: false
	};
	const schema$1 = {
		type: "object",
		additionalProperties: parseDef(def.valueType._def, {
			...refs,
			currentPath: [...refs.currentPath, "additionalProperties"]
		}) ?? {}
	};
	if (refs.target === "openApi3") return schema$1;
	if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.checks?.length) {
		const { type,...keyType } = parseStringDef(def.keyType._def, refs);
		return {
			...schema$1,
			propertyNames: keyType
		};
	} else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) return {
		...schema$1,
		propertyNames: { enum: def.keyType._def.values }
	};
else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.type._def.checks?.length) {
		const { type,...keyType } = parseBrandedDef(def.keyType._def, refs);
		return {
			...schema$1,
			propertyNames: keyType
		};
	}
	return schema$1;
}

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/map.js
function parseMapDef(def, refs) {
	if (refs.mapStrategy === "record") return parseRecordDef(def, refs);
	const keys = parseDef(def.keyType._def, {
		...refs,
		currentPath: [
			...refs.currentPath,
			"items",
			"items",
			"0"
		]
	}) || {};
	const values = parseDef(def.valueType._def, {
		...refs,
		currentPath: [
			...refs.currentPath,
			"items",
			"items",
			"1"
		]
	}) || {};
	return {
		type: "array",
		maxItems: 125,
		items: {
			type: "array",
			items: [keys, values],
			minItems: 2,
			maxItems: 2
		}
	};
}

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js
function parseNativeEnumDef(def) {
	const object = def.values;
	const actualKeys = Object.keys(def.values).filter((key) => {
		return typeof object[object[key]] !== "number";
	});
	const actualValues = actualKeys.map((key) => object[key]);
	const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
	return {
		type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
		enum: actualValues
	};
}

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/never.js
function parseNeverDef() {
	return { not: {} };
}

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/null.js
function parseNullDef(refs) {
	return refs.target === "openApi3" ? {
		enum: ["null"],
		nullable: true
	} : { type: "null" };
}

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/union.js
const primitiveMappings = {
	ZodString: "string",
	ZodNumber: "number",
	ZodBigInt: "integer",
	ZodBoolean: "boolean",
	ZodNull: "null"
};
function parseUnionDef(def, refs) {
	if (refs.target === "openApi3") return asAnyOf(def, refs);
	const options$1 = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
	if (options$1.every((x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length))) {
		const types = options$1.reduce((types$1, x) => {
			const type = primitiveMappings[x._def.typeName];
			return type && !types$1.includes(type) ? [...types$1, type] : types$1;
		}, []);
		return { type: types.length > 1 ? types : types[0] };
	} else if (options$1.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
		const types = options$1.reduce((acc, x) => {
			const type = typeof x._def.value;
			switch (type) {
				case "string":
				case "number":
				case "boolean": return [...acc, type];
				case "bigint": return [...acc, "integer"];
				case "object": if (x._def.value === null) return [...acc, "null"];
				case "symbol":
				case "undefined":
				case "function":
				default: return acc;
			}
		}, []);
		if (types.length === options$1.length) {
			const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
			return {
				type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
				enum: options$1.reduce((acc, x) => {
					return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
				}, [])
			};
		}
	} else if (options$1.every((x) => x._def.typeName === "ZodEnum")) return {
		type: "string",
		enum: options$1.reduce((acc, x) => [...acc, ...x._def.values.filter((x$1) => !acc.includes(x$1))], [])
	};
	return asAnyOf(def, refs);
}
const asAnyOf = (def, refs) => {
	const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => parseDef(x._def, {
		...refs,
		currentPath: [
			...refs.currentPath,
			"anyOf",
			`${i}`
		]
	})).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
	return anyOf.length ? { anyOf } : undefined;
};

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js
function parseNullableDef(def, refs) {
	if ([
		"ZodString",
		"ZodNumber",
		"ZodBigInt",
		"ZodBoolean",
		"ZodNull"
	].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
		if (refs.target === "openApi3") return {
			type: primitiveMappings[def.innerType._def.typeName],
			nullable: true
		};
		return { type: [primitiveMappings[def.innerType._def.typeName], "null"] };
	}
	if (refs.target === "openApi3") {
		const base$1 = parseDef(def.innerType._def, {
			...refs,
			currentPath: [...refs.currentPath]
		});
		if (base$1 && "$ref" in base$1) return {
			allOf: [base$1],
			nullable: true
		};
		return base$1 && {
			...base$1,
			nullable: true
		};
	}
	const base = parseDef(def.innerType._def, {
		...refs,
		currentPath: [
			...refs.currentPath,
			"anyOf",
			"0"
		]
	});
	return base && { anyOf: [base, { type: "null" }] };
}

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/number.js
function parseNumberDef(def, refs) {
	const res = { type: "number" };
	if (!def.checks) return res;
	for (const check of def.checks) switch (check.kind) {
		case "int":
			res.type = "integer";
			addErrorMessage(res, "type", check.message, refs);
			break;
		case "min":
			if (refs.target === "jsonSchema7") if (check.inclusive) setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
else setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
else {
				if (!check.inclusive) res.exclusiveMinimum = true;
				setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
			}
			break;
		case "max":
			if (refs.target === "jsonSchema7") if (check.inclusive) setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
else setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
else {
				if (!check.inclusive) res.exclusiveMaximum = true;
				setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
			}
			break;
		case "multipleOf":
			setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
			break;
	}
	return res;
}

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/object.js
function decideAdditionalProperties(def, refs) {
	if (refs.removeAdditionalStrategy === "strict") return def.catchall._def.typeName === "ZodNever" ? def.unknownKeys !== "strict" : parseDef(def.catchall._def, {
		...refs,
		currentPath: [...refs.currentPath, "additionalProperties"]
	}) ?? true;
else return def.catchall._def.typeName === "ZodNever" ? def.unknownKeys === "passthrough" : parseDef(def.catchall._def, {
		...refs,
		currentPath: [...refs.currentPath, "additionalProperties"]
	}) ?? true;
}
function parseObjectDef(def, refs) {
	const result = {
		type: "object",
		...Object.entries(def.shape()).reduce((acc, [propName, propDef]) => {
			if (propDef === undefined || propDef._def === undefined) return acc;
			const parsedDef = parseDef(propDef._def, {
				...refs,
				currentPath: [
					...refs.currentPath,
					"properties",
					propName
				],
				propertyPath: [
					...refs.currentPath,
					"properties",
					propName
				]
			});
			if (parsedDef === undefined) return acc;
			return {
				properties: {
					...acc.properties,
					[propName]: parsedDef
				},
				required: propDef.isOptional() ? acc.required : [...acc.required, propName]
			};
		}, {
			properties: {},
			required: []
		}),
		additionalProperties: decideAdditionalProperties(def, refs)
	};
	if (!result.required.length) delete result.required;
	return result;
}

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/optional.js
const parseOptionalDef = (def, refs) => {
	if (refs.currentPath.toString() === refs.propertyPath?.toString()) return parseDef(def.innerType._def, refs);
	const innerSchema = parseDef(def.innerType._def, {
		...refs,
		currentPath: [
			...refs.currentPath,
			"anyOf",
			"1"
		]
	});
	return innerSchema ? { anyOf: [{ not: {} }, innerSchema] } : {};
};

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js
const parsePipelineDef = (def, refs) => {
	if (refs.pipeStrategy === "input") return parseDef(def.in._def, refs);
else if (refs.pipeStrategy === "output") return parseDef(def.out._def, refs);
	const a = parseDef(def.in._def, {
		...refs,
		currentPath: [
			...refs.currentPath,
			"allOf",
			"0"
		]
	});
	const b = parseDef(def.out._def, {
		...refs,
		currentPath: [
			...refs.currentPath,
			"allOf",
			a ? "1" : "0"
		]
	});
	return { allOf: [a, b].filter((x) => x !== undefined) };
};

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/promise.js
function parsePromiseDef(def, refs) {
	return parseDef(def.type._def, refs);
}

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/set.js
function parseSetDef(def, refs) {
	const items = parseDef(def.valueType._def, {
		...refs,
		currentPath: [...refs.currentPath, "items"]
	});
	const schema$1 = {
		type: "array",
		uniqueItems: true,
		items
	};
	if (def.minSize) setResponseValueAndErrors(schema$1, "minItems", def.minSize.value, def.minSize.message, refs);
	if (def.maxSize) setResponseValueAndErrors(schema$1, "maxItems", def.maxSize.value, def.maxSize.message, refs);
	return schema$1;
}

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js
function parseTupleDef(def, refs) {
	if (def.rest) return {
		type: "array",
		minItems: def.items.length,
		items: def.items.map((x, i) => parseDef(x._def, {
			...refs,
			currentPath: [
				...refs.currentPath,
				"items",
				`${i}`
			]
		})).reduce((acc, x) => x === undefined ? acc : [...acc, x], []),
		additionalItems: parseDef(def.rest._def, {
			...refs,
			currentPath: [...refs.currentPath, "additionalItems"]
		})
	};
else return {
		type: "array",
		minItems: def.items.length,
		maxItems: def.items.length,
		items: def.items.map((x, i) => parseDef(x._def, {
			...refs,
			currentPath: [
				...refs.currentPath,
				"items",
				`${i}`
			]
		})).reduce((acc, x) => x === undefined ? acc : [...acc, x], [])
	};
}

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js
function parseUndefinedDef() {
	return { not: {} };
}

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js
function parseUnknownDef() {
	return {};
}

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js
const parseReadonlyDef = (def, refs) => {
	return parseDef(def.innerType._def, refs);
};

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parseDef.js
function parseDef(def, refs, forceResolution = false) {
	const seenItem = refs.seen.get(def);
	if (refs.override) {
		const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
		if (overrideResult !== ignoreOverride) return overrideResult;
	}
	if (seenItem && !forceResolution) {
		const seenSchema = get$ref(seenItem, refs);
		if (seenSchema !== undefined) return seenSchema;
	}
	const newItem = {
		def,
		path: refs.currentPath,
		jsonSchema: undefined
	};
	refs.seen.set(def, newItem);
	const jsonSchema = selectParser(def, def.typeName, refs);
	if (jsonSchema) addMeta(def, refs, jsonSchema);
	newItem.jsonSchema = jsonSchema;
	return jsonSchema;
}
const get$ref = (item, refs) => {
	switch (refs.$refStrategy) {
		case "root": return { $ref: item.path.join("/") };
		case "relative": return { $ref: getRelativePath(refs.currentPath, item.path) };
		case "none":
		case "seen": {
			if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
				console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
				return {};
			}
			return refs.$refStrategy === "seen" ? {} : undefined;
		}
	}
};
const getRelativePath = (pathA, pathB) => {
	let i = 0;
	for (; i < pathA.length && i < pathB.length; i++) if (pathA[i] !== pathB[i]) break;
	return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};
const selectParser = (def, typeName, refs) => {
	switch (typeName) {
		case ZodFirstPartyTypeKind.ZodString: return parseStringDef(def, refs);
		case ZodFirstPartyTypeKind.ZodNumber: return parseNumberDef(def, refs);
		case ZodFirstPartyTypeKind.ZodObject: return parseObjectDef(def, refs);
		case ZodFirstPartyTypeKind.ZodBigInt: return parseBigintDef(def, refs);
		case ZodFirstPartyTypeKind.ZodBoolean: return parseBooleanDef();
		case ZodFirstPartyTypeKind.ZodDate: return parseDateDef(def, refs);
		case ZodFirstPartyTypeKind.ZodUndefined: return parseUndefinedDef();
		case ZodFirstPartyTypeKind.ZodNull: return parseNullDef(refs);
		case ZodFirstPartyTypeKind.ZodArray: return parseArrayDef(def, refs);
		case ZodFirstPartyTypeKind.ZodUnion:
		case ZodFirstPartyTypeKind.ZodDiscriminatedUnion: return parseUnionDef(def, refs);
		case ZodFirstPartyTypeKind.ZodIntersection: return parseIntersectionDef(def, refs);
		case ZodFirstPartyTypeKind.ZodTuple: return parseTupleDef(def, refs);
		case ZodFirstPartyTypeKind.ZodRecord: return parseRecordDef(def, refs);
		case ZodFirstPartyTypeKind.ZodLiteral: return parseLiteralDef(def, refs);
		case ZodFirstPartyTypeKind.ZodEnum: return parseEnumDef(def);
		case ZodFirstPartyTypeKind.ZodNativeEnum: return parseNativeEnumDef(def);
		case ZodFirstPartyTypeKind.ZodNullable: return parseNullableDef(def, refs);
		case ZodFirstPartyTypeKind.ZodOptional: return parseOptionalDef(def, refs);
		case ZodFirstPartyTypeKind.ZodMap: return parseMapDef(def, refs);
		case ZodFirstPartyTypeKind.ZodSet: return parseSetDef(def, refs);
		case ZodFirstPartyTypeKind.ZodLazy: return parseDef(def.getter()._def, refs);
		case ZodFirstPartyTypeKind.ZodPromise: return parsePromiseDef(def, refs);
		case ZodFirstPartyTypeKind.ZodNaN:
		case ZodFirstPartyTypeKind.ZodNever: return parseNeverDef();
		case ZodFirstPartyTypeKind.ZodEffects: return parseEffectsDef(def, refs);
		case ZodFirstPartyTypeKind.ZodAny: return parseAnyDef();
		case ZodFirstPartyTypeKind.ZodUnknown: return parseUnknownDef();
		case ZodFirstPartyTypeKind.ZodDefault: return parseDefaultDef(def, refs);
		case ZodFirstPartyTypeKind.ZodBranded: return parseBrandedDef(def, refs);
		case ZodFirstPartyTypeKind.ZodReadonly: return parseReadonlyDef(def, refs);
		case ZodFirstPartyTypeKind.ZodCatch: return parseCatchDef(def, refs);
		case ZodFirstPartyTypeKind.ZodPipeline: return parsePipelineDef(def, refs);
		case ZodFirstPartyTypeKind.ZodFunction:
		case ZodFirstPartyTypeKind.ZodVoid:
		case ZodFirstPartyTypeKind.ZodSymbol: return undefined;
		default: return ((_) => undefined)(typeName);
	}
};
const addMeta = (def, refs, jsonSchema) => {
	if (def.description) {
		jsonSchema.description = def.description;
		if (refs.markdownDescription) jsonSchema.markdownDescription = def.description;
	}
	return jsonSchema;
};

//#endregion
//#region ../../node_modules/.pnpm/zod-to-json-schema@3.23.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js
const zodToJsonSchema = (schema$1, options$1) => {
	const refs = getRefs(options$1);
	const definitions = typeof options$1 === "object" && options$1.definitions ? Object.entries(options$1.definitions).reduce((acc, [name$1, schema$2]) => ({
		...acc,
		[name$1]: parseDef(schema$2._def, {
			...refs,
			currentPath: [
				...refs.basePath,
				refs.definitionPath,
				name$1
			]
		}, true) ?? {}
	}), {}) : undefined;
	const name = typeof options$1 === "string" ? options$1 : options$1?.nameStrategy === "title" ? undefined : options$1?.name;
	const main$1 = parseDef(schema$1._def, name === undefined ? refs : {
		...refs,
		currentPath: [
			...refs.basePath,
			refs.definitionPath,
			name
		]
	}, false) ?? {};
	const title = typeof options$1 === "object" && options$1.name !== undefined && options$1.nameStrategy === "title" ? options$1.name : undefined;
	if (title !== undefined) main$1.title = title;
	const combined = name === undefined ? definitions ? {
		...main$1,
		[refs.definitionPath]: definitions
	} : main$1 : {
		$ref: [
			...refs.$refStrategy === "relative" ? [] : refs.basePath,
			refs.definitionPath,
			name
		].join("/"),
		[refs.definitionPath]: {
			...definitions,
			[name]: main$1
		}
	};
	if (refs.target === "jsonSchema7") combined.$schema = "http://json-schema.org/draft-07/schema#";
else if (refs.target === "jsonSchema2019-09") combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
	return combined;
};

//#endregion
//#region src/utils/zod-ext.ts
const stringOrRegExp = () => z.string().or(z.instanceof(RegExp));
const optionalStringArray = () => z.string().array().optional();
const returnTrue = () => true;
const phantom = () => z.custom(returnTrue);
const voidNullableWith = (t) => {
	return voidNullable().or(t);
};
const voidNullable = () => {
	return z.void().or(z.null()).or(z.undefined());
};

//#endregion
//#region src/options/input-options-schema.ts
const inputOptionSchema = z.string().or(z.string().array()).or(z.record(z.string()));
const externalSchema = stringOrRegExp().or(stringOrRegExp().array()).or(z.function().args(z.string(), z.string().optional(), z.boolean()).returns(voidNullableWith(z.boolean())));
const moduleTypesSchema = z.record(z.literal("js").or(z.literal("jsx")).or(z.literal("ts")).or(z.literal("tsx")).or(z.literal("json")).or(z.literal("text")).or(z.literal("base64")).or(z.literal("dataurl")).or(z.literal("binary")).or(z.literal("empty")).or(z.literal("css")));
const jsxOptionsSchema = z.strictObject({
	mode: z.literal("classic").or(z.literal("automatic")).describe("Jsx transformation mode").optional(),
	factory: z.string().describe("Jsx element transformation").optional(),
	fragment: z.string().describe("Jsx fragment transformation").optional(),
	importSource: z.string().describe("Import the factory of element and fragment if mode is classic").optional(),
	jsxImportSource: z.string().describe("Import the factory of element and fragment if mode is automatic").optional(),
	refresh: z.boolean().describe("React refresh transformation").optional(),
	development: z.boolean().describe("Development specific information").optional()
});
const stringOrRegExpSchema = stringOrRegExp().or(stringOrRegExp().array());
const watchOptionsSchema = z.strictObject({
	skipWrite: z.boolean().describe("Skip the bundle.write() step").optional(),
	notify: z.strictObject({
		pollInterval: z.number().optional(),
		compareContents: z.boolean().optional()
	}).describe("Notify options").optional(),
	include: stringOrRegExpSchema.optional(),
	exclude: stringOrRegExpSchema.optional(),
	chokidar: z.any().optional()
});
const checksOptionsSchema = z.strictObject({ circularDependency: z.boolean().describe("Wether to emit warnings when detecting circular dependencies").optional() });
const inputOptionsSchema = z.strictObject({
	input: inputOptionSchema.optional(),
	plugins: phantom().optional(),
	external: externalSchema.optional(),
	resolve: z.strictObject({
		alias: z.record(z.array(z.string()).or(z.string())).optional(),
		aliasFields: z.array(z.array(z.string())).optional(),
		conditionNames: optionalStringArray(),
		extensionAlias: z.record(z.string(), z.array(z.string())).optional(),
		exportsFields: z.array(z.array(z.string())).optional(),
		extensions: optionalStringArray(),
		mainFields: optionalStringArray(),
		mainFiles: optionalStringArray(),
		modules: optionalStringArray(),
		symlinks: z.boolean().optional(),
		tsconfigFilename: z.string().optional()
	}).optional(),
	cwd: z.string().describe("Current working directory").optional(),
	platform: z.literal("node").or(z.literal("browser")).or(z.literal("neutral")).describe(`Platform for which the code should be generated (node, ${colors.underline("browser")}, neutral)`).optional(),
	shimMissingExports: z.boolean().describe(`Create shim variables for missing exports`).optional(),
	treeshake: TreeshakingOptionsSchema.optional(),
	logLevel: LogLevelOptionSchema.describe(`Log level (${colors.dim("silent")}, ${colors.underline(colors.gray("info"))}, debug, ${colors.yellow("warn")})`).optional(),
	onLog: z.function().args(LogLevelSchema, RollupLogSchema, z.function().args(LogLevelWithErrorSchema, RollupLogWithStringSchema)).optional(),
	onwarn: z.function().args(RollupLogSchema, z.function().args(RollupLogWithStringSchema.or(z.function().returns(RollupLogWithStringSchema)))).optional(),
	moduleTypes: moduleTypesSchema.describe("Module types for customized extensions").optional(),
	experimental: z.strictObject({
		enableComposingJsPlugins: z.boolean().optional(),
		strictExecutionOrder: z.boolean().optional(),
		disableLiveBindings: z.boolean().optional(),
		resolveNewUrlToAsset: z.boolean().optional()
	}).optional(),
	define: z.record(z.string()).describe("Define global variables").optional(),
	inject: z.record(z.string().or(z.tuple([z.string(), z.string()]))).optional(),
	profilerNames: z.boolean().optional(),
	jsx: jsxOptionsSchema.optional(),
	watch: watchOptionsSchema.or(z.literal(false)).optional(),
	dropLabels: z.array(z.string()).describe("Remove labeled statements with these label names").optional(),
	checks: checksOptionsSchema.optional()
});
const inputCliOptionsSchema = inputOptionsSchema.extend({
	external: z.array(z.string()).describe("Comma-separated list of module ids to exclude from the bundle `<module-id>,...`").optional(),
	inject: z.record(z.string()).describe("Inject import statements on demand").optional(),
	treeshake: z.boolean().describe("enable treeshaking").default(true).optional()
}).omit({
	input: true,
	plugins: true,
	onwarn: true,
	onLog: true,
	resolve: true,
	experimental: true,
	profilerNames: true,
	watch: true
});

//#endregion
//#region src/options/output-options-schema.ts
const ModuleFormatSchema = z.literal("es").or(z.literal("cjs")).or(z.literal("esm")).or(z.literal("module")).or(z.literal("commonjs")).or(z.literal("iife")).or(z.literal("umd")).describe(`Output format of the generated bundle (supports ${colors.underline("esm")}, cjs, and iife)`);
const addonFunctionSchema = z.function().args(phantom()).returns(z.string().or(z.promise(z.string())));
const chunkFileNamesFunctionSchema = z.function().args(phantom()).returns(z.string());
const GlobalsFunctionSchema = z.function().args(z.string()).returns(z.string());
const outputOptionsSchema = z.strictObject({
	dir: z.string().describe("Output directory, defaults to `dist` if `file` is not set").optional(),
	file: z.string().describe("Single output file").optional(),
	exports: z.literal("auto").or(z.literal("named")).or(z.literal("default")).or(z.literal("none")).describe(`Specify a export mode (${colors.underline("auto")}, named, default, none)`).optional(),
	hashCharacters: z.literal("base64").or(z.literal("base36")).or(z.literal("hex")).describe("Use the specified character set for file hashes").optional(),
	format: ModuleFormatSchema.optional(),
	sourcemap: z.boolean().or(z.literal("inline")).or(z.literal("hidden")).describe(`Generate sourcemap (\`-s inline\` for inline, or ${colors.bold("pass the `-s` on the last argument if you want to generate `.map` file")})`).optional(),
	sourcemapIgnoreList: z.boolean().or(phantom()).optional(),
	sourcemapPathTransform: phantom().optional(),
	banner: z.string().or(addonFunctionSchema).optional(),
	footer: z.string().or(addonFunctionSchema).optional(),
	intro: z.string().or(addonFunctionSchema).optional(),
	outro: z.string().or(addonFunctionSchema).optional(),
	extend: z.boolean().describe("Extend global variable defined by name in IIFE / UMD formats").optional(),
	esModule: z.literal("if-default-prop").or(z.boolean()).optional(),
	assetFileNames: z.string().describe("Name pattern for asset files").optional(),
	entryFileNames: z.string().or(chunkFileNamesFunctionSchema).describe("Name pattern for emitted entry chunks").optional(),
	chunkFileNames: z.string().or(chunkFileNamesFunctionSchema).describe("Name pattern for emitted secondary chunks").optional(),
	cssEntryFileNames: z.string().or(chunkFileNamesFunctionSchema).describe("Name pattern for emitted css entry chunks").optional(),
	cssChunkFileNames: z.string().or(chunkFileNamesFunctionSchema).describe("Name pattern for emitted css secondary chunks").optional(),
	minify: z.boolean().describe("Minify the bundled file.").optional(),
	name: z.string().describe("Name for UMD / IIFE format outputs").optional(),
	globals: z.record(z.string()).or(GlobalsFunctionSchema).describe("Global variable of UMD / IIFE dependencies (syntax: `key=value`)").optional(),
	externalLiveBindings: z.boolean().describe("external live bindings").default(true).optional(),
	inlineDynamicImports: z.boolean().describe("Inline dynamic imports").default(false).optional(),
	advancedChunks: z.strictObject({
		minSize: z.number().optional(),
		minShareCount: z.number().optional(),
		groups: z.array(z.strictObject({
			name: z.string(),
			test: z.string().or(z.instanceof(RegExp)).optional(),
			priority: z.number().optional(),
			minSize: z.number().optional(),
			minShareCount: z.number().optional()
		})).optional()
	}).optional(),
	comments: z.enum(["none", "preserve-legal"]).describe("Control comments in the output").optional()
});
const getAddonDescription = (placement, wrapper) => {
	return `Code to insert the ${colors.bold(placement)} of the bundled file (${colors.bold(wrapper)} the wrapper function)`;
};
const outputCliOptionsSchema = outputOptionsSchema.extend({
	banner: z.string().describe(getAddonDescription("top", "outside")).optional(),
	footer: z.string().describe(getAddonDescription("bottom", "outside")).optional(),
	intro: z.string().describe(getAddonDescription("top", "inside")).optional(),
	outro: z.string().describe(getAddonDescription("bottom", "inside")).optional(),
	esModule: z.boolean().describe("Always generate `__esModule` marks in non-ESM formats, defaults to `if-default-prop` (use `--no-esModule` to always disable)").optional(),
	globals: z.record(z.string()).describe("Global variable of UMD / IIFE dependencies (syntax: `key=value`)").optional(),
	advancedChunks: z.strictObject({
		minSize: z.number().describe("Minimum size of the chunk").optional(),
		minShareCount: z.number().describe("Minimum share count of the chunk").optional()
	}).optional()
}).omit({
	sourcemapPathTransform: true,
	sourcemapIgnoreList: true
});

//#endregion
//#region src/cli/arguments/schema.ts
const cliOptionsSchema = z.strictObject({
	config: z.string().or(z.boolean()).describe("Path to the config file (default: `rolldown.config.js`)").optional(),
	help: z.boolean().describe("Show help").optional(),
	version: z.boolean().describe("Show version number").optional(),
	watch: z.boolean().describe("Watch files in bundle and rebuild on changes").optional()
}).merge(inputCliOptionsSchema).merge(outputCliOptionsSchema);
const schema = zodToJsonSchema(cliOptionsSchema);

//#endregion
//#region src/cli/arguments/alias.ts
const alias = {
	config: {
		abbreviation: "c",
		hint: "filename",
		default: "rolldown.config.js"
	},
	help: { abbreviation: "h" },
	version: { abbreviation: "v" },
	watch: { abbreviation: "w" },
	dir: { abbreviation: "d" },
	file: { abbreviation: "o" },
	external: { abbreviation: "e" },
	format: { abbreviation: "f" },
	name: { abbreviation: "n" },
	globals: { abbreviation: "g" },
	sourcemap: {
		abbreviation: "s",
		default: true
	},
	minify: { abbreviation: "m" },
	platform: { abbreviation: "p" },
	assetFileNames: { hint: "name" },
	chunkFileNames: { hint: "name" },
	entryFileNames: { hint: "name" },
	externalLiveBindings: {
		default: true,
		reverse: true
	},
	treeshake: {
		default: true,
		reverse: true
	},
	moduleTypes: { hint: "types" }
};

//#endregion
//#region src/cli/arguments/utils.ts
function getSchemaType(schema$1) {
	if ("anyOf" in schema$1) {
		const types = schema$1.anyOf.map((s) => getSchemaType(s));
		if (types.includes("object")) return "object";
else if (types.includes("array")) return "array";
else if (types.includes("string")) return "string";
else if (types.includes("number")) return "number";
else if (types.includes("boolean")) return "boolean";
	}
	if ("type" in schema$1) return schema$1.type;
	return "object";
}
function flattenSchema(schema$1, base = {}, parent = "") {
	for (const [k, value] of Object.entries(schema$1)) {
		const key = parent ? `${parent}.${k}` : k;
		if (getSchemaType(value) === "object") if ("properties" in value) flattenSchema(value.properties, base, key);
else base[key] = value;
else base[key] = value;
	}
	return base;
}
function setNestedProperty(obj, path$1, value) {
	const keys = path$1.split(".");
	let current = obj;
	for (let i = 0; i < keys.length - 1; i++) {
		if (!current[keys[i]]) current[keys[i]] = {};
		current = current[keys[i]];
	}
	const finalKey = keys[keys.length - 1];
	Object.defineProperty(current, finalKey, {
		value,
		writable: true,
		enumerable: true,
		configurable: true
	});
}
function camelCaseToKebabCase(str) {
	return str.replace(/[A-Z]/g, (match) => `-${match.toLowerCase()}`);
}
function kebabCaseToCamelCase(str) {
	return str.replace(/-./g, (match) => match[1].toUpperCase());
}

//#endregion
//#region src/cli/arguments/normalize.ts
function normalizeCliOptions(cliOptions, positionals) {
	const parsed = cliOptionsSchema.safeParse(cliOptions);
	const options$1 = parsed.data ?? {};
	if (!parsed.success) {
		parsed.error.errors.forEach((error) => {
			logger.error(`Invalid value for option ${error.path.join(", ")}. You can use \`rolldown -h\` to see the help.`);
		});
		process.exit(1);
	}
	const result = {
		input: {},
		output: {},
		help: options$1.help ?? false,
		version: options$1.version ?? false,
		watch: options$1.watch ?? false
	};
	if (typeof options$1.config === "string") result.config = options$1.config ? options$1.config : "rolldown.config.js";
	const reservedKeys = [
		"help",
		"version",
		"config",
		"watch"
	];
	const keysOfInput = inputCliOptionsSchema.keyof()._def.values;
	const keysOfOutput = outputCliOptionsSchema.keyof()._def.values;
	for (let [key, value] of Object.entries(options$1)) {
		const keys = key.split(".");
		const [primary] = keys;
		if (keysOfInput.includes(primary)) setNestedProperty(result.input, key, value);
else if (keysOfOutput.includes(primary)) setNestedProperty(result.output, key, value);
else if (!reservedKeys.includes(key)) {
			logger.error(`Unknown option: ${key}`);
			process.exit(1);
		}
	}
	if (!result.config && positionals.length > 0) result.input.input = positionals;
	return result;
}

//#endregion
//#region src/cli/arguments/index.ts
const flattenedSchema = flattenSchema(schema.properties);
const options = Object.fromEntries(Object.entries(flattenedSchema).map(([key, schema$1]) => {
	const config = Object.getOwnPropertyDescriptor(alias, key)?.value;
	const type = getSchemaType(schema$1);
	const result = {
		type: type === "boolean" ? "boolean" : "string",
		description: schema$1?.description ?? config?.description ?? "",
		hint: config?.hint
	};
	if (config && config?.abbreviation) result.short = config?.abbreviation;
	if (config && config.reverse) if (result.description.startsWith("enable")) result.description = result.description.replace("enable", "disable");
else result.description = `disable ${result.description}`;
	key = camelCaseToKebabCase(key);
	return [config?.reverse ? `no-${key}` : key, result];
}));
function parseCliArguments() {
	const { values, tokens, positionals } = parseArgs({
		options,
		tokens: true,
		allowPositionals: true,
		strict: false
	});
	tokens.filter((token) => token.kind === "option").forEach((option) => {
		let negative = false;
		if (option.name.startsWith("no-")) {
			const name = kebabCaseToCamelCase(option.name.substring(3));
			if (name in flattenedSchema) {
				delete values[option.name];
				option.name = name;
				negative = true;
			}
		}
		delete values[option.name];
		option.name = kebabCaseToCamelCase(option.name);
		let originalType = flattenedSchema[option.name];
		if (!originalType) {
			logger.error(`Invalid option: ${option.rawName}. We will ignore this option.`);
			process.exit(1);
		}
		let type = getSchemaType(originalType);
		if (type === "string" && typeof option.value !== "string") {
			let opt = option;
			let defaultValue = Object.getOwnPropertyDescriptor(alias, opt.name)?.value;
			Object.defineProperty(values, opt.name, {
				value: defaultValue.default ?? "",
				enumerable: true,
				configurable: true,
				writable: true
			});
		} else if (type === "object" && typeof option.value === "string") {
			const [key, value] = option.value.split(",").map((x) => x.split("="))[0];
			if (!values[option.name]) Object.defineProperty(values, option.name, {
				value: {},
				enumerable: true,
				configurable: true,
				writable: true
			});
			if (key && value) Object.defineProperty(values[option.name], key, {
				value,
				enumerable: true,
				configurable: true,
				writable: true
			});
		} else if (type === "array" && typeof option.value === "string") {
			if (!values[option.name]) Object.defineProperty(values, option.name, {
				value: [],
				enumerable: true,
				configurable: true,
				writable: true
			});
			values[option.name].push(option.value);
		} else if (type === "boolean") Object.defineProperty(values, option.name, {
			value: !negative,
			enumerable: true,
			configurable: true,
			writable: true
		});
else Object.defineProperty(values, option.name, {
			value: option.value ?? "",
			enumerable: true,
			configurable: true,
			writable: true
		});
	});
	return normalizeCliOptions(values, positionals);
}

//#endregion
//#region src/cli/commands/help.ts
const introduction = `${colors.gray(`${description} (rolldown v${version})`)}

${colors.bold(colors.underline("USAGE"))} ${colors.cyan("rolldown -c <config>")} or ${colors.cyan("rolldown <input> <options>")}`;
const examples = [
	{
		title: "Bundle with a config file `rolldown.config.mjs`",
		command: "rolldown -c rolldown.config.mjs"
	},
	{
		title: "Bundle the `src/main.ts` to `dist` with `cjs` format",
		command: "rolldown src/main.ts -d dist -f cjs"
	},
	{
		title: "Bundle the `src/main.ts` and handle the `.png` assets to Data URL",
		command: "rolldown src/main.ts -d dist --moduleTypes .png=dataurl"
	},
	{
		title: "Bundle the `src/main.tsx` and minify the output with sourcemap",
		command: "rolldown src/main.tsx -d dist -m -s"
	},
	{
		title: "Create self-executing IIFE using external jQuery as `$` and `_`",
		command: "rolldown src/main.ts -d dist -n bundle -f iife -e jQuery,window._ -g jQuery=$"
	}
];
const notes = [
	"Due to the API limitation, you need to pass `-s` for `.map` sourcemap file as the last argument.",
	"If you are using the configuration, please pass the `-c` as the last argument if you ignore the default configuration file.",
	"CLI options will override the configuration file.",
	"For more information, please visit https://rolldown.rs/."
];
function showHelp() {
	logger.log(introduction);
	logger.log("");
	logger.log(`${colors.bold(colors.underline("OPTIONS"))}`);
	logger.log("");
	logger.log(Object.entries(options).sort(([a], [b]) => {
		if (options[a].short && !options[b].short) return -1;
		if (!options[a].short && options[b].short) return 1;
		if (options[a].short && options[b].short) return options[a].short.localeCompare(options[b].short);
		return a.localeCompare(b);
	}).map(([option, { type, short, hint, description: description$1 }]) => {
		let optionStr = `  --${option} `;
		option = camelCaseToKebabCase(option);
		if (short) optionStr += `-${short}, `;
		if (type === "string") optionStr += `<${hint ?? option}>`;
		if (description$1 && description$1.length > 0) description$1 = description$1[0].toUpperCase() + description$1.slice(1);
		return colors.cyan(optionStr.padEnd(30)) + description$1 + (description$1 && description$1?.endsWith(".") ? "" : ".");
	}).join("\n"));
	logger.log("");
	logger.log(`${colors.bold(colors.underline("EXAMPLES"))}`);
	logger.log("");
	examples.forEach(({ title, command }, ord) => {
		logger.log(`  ${ord + 1}. ${title}:`);
		logger.log(`    ${colors.cyan(command)}`);
		logger.log("");
	});
	logger.log(`${colors.bold(colors.underline("NOTES"))}`);
	logger.log("");
	notes.forEach((note) => {
		logger.log(`  * ${colors.gray(note)}`);
	});
}

//#endregion
//#region src/cli/index.ts
async function main() {
	const cliOptions = parseCliArguments();
	if (cliOptions.config) {
		await bundleWithConfig(cliOptions.config, cliOptions);
		return;
	}
	if ("input" in cliOptions.input) {
		await bundleWithCliOptions(cliOptions);
		return;
	}
	if (cliOptions.version) {
		logger.log(`rolldown v${version}`);
		return;
	}
	showHelp();
}
main().catch((err) => {
	console.error(err);
	process$1.exit(1);
});

//#endregion