const require_chunk = require('./chunk-qZFfknuJ.cjs');
const node_buffer = require_chunk.__toESM(require("node:buffer"));
const zod = require_chunk.__toESM(require("zod"));
const node_path = require_chunk.__toESM(require("node:path"));
const node_worker_threads = require_chunk.__toESM(require("node:worker_threads"));
const node_os = require_chunk.__toESM(require("node:os"));

//#region src/utils/define-config.ts
function defineConfig(config) {
	return config;
}

//#endregion
//#region src/utils/asset-source.ts
function transformAssetSource(bindingAssetSource$1) {
	return bindingAssetSource$1.inner;
}
function bindingAssetSource(source) {
	return { inner: source };
}

//#endregion
//#region src/types/sourcemap.ts
function bindingifySourcemap$1(map) {
	if (map == null) return;
	return { inner: typeof map === "string" ? map : {
		file: map.file ?? undefined,
		mappings: map.mappings,
		sourceRoot: map.sourceRoot,
		sources: map.sources?.map((s) => s ?? undefined),
		sourcesContent: map.sourcesContent?.map((s) => s ?? undefined),
		names: map.names
	} };
}

//#endregion
//#region src/utils/error.ts
function normalizeErrors(rawErrors) {
	const errors = rawErrors.map((e) => e instanceof Error ? e : Object.assign(new Error(), {
		kind: e.kind,
		message: e.message,
		stack: undefined
	}));
	let summary = `Build failed with ${errors.length} error${errors.length < 2 ? "" : "s"}:\n`;
	for (let i = 0; i < errors.length; i++) {
		if (i >= 5) {
			summary += "\n...";
			break;
		}
		summary += getErrorMessage(errors[i]) + "\n";
	}
	const wrapper = new Error(summary);
	Object.defineProperty(wrapper, "errors", {
		configurable: true,
		enumerable: true,
		get: () => errors,
		set: (value) => Object.defineProperty(wrapper, "errors", {
			configurable: true,
			enumerable: true,
			value
		})
	});
	return wrapper;
}
function getErrorMessage(e) {
	let s = "";
	if (e.plugin) s += `[plugin ${e.plugin}]`;
	const id = e.id ?? e.loc?.file;
	if (id) {
		s += " " + id;
		if (e.loc) s += `:${e.loc.line}:${e.loc.column}`;
	}
	if (s) s += "\n";
	const message = `${e.name ?? "Error"}: ${e.message}`;
	s += message;
	if (e.frame) s = joinNewLine(s, e.frame);
	if (e.stack) s = joinNewLine(s, e.stack.replace(message, ""));
	return s;
}
function joinNewLine(s1, s2) {
	return s1.replace(/\n+$/, "") + "\n" + s2.replace(/^\n+/, "");
}

//#endregion
//#region src/utils/transform-rendered-module.ts
function transformToRenderedModule(bindingRenderedModule) {
	return {
		get code() {
			return bindingRenderedModule.code;
		},
		get renderedLength() {
			return bindingRenderedModule.code?.length || 0;
		}
	};
}

//#endregion
//#region src/utils/transform-rendered-chunk.ts
function transformRenderedChunk(chunk) {
	return {
		...chunk,
		get modules() {
			return transformChunkModules(chunk.modules);
		}
	};
}
function transformChunkModules(modules) {
	const result = {};
	for (const [id, mod] of Object.entries(modules)) result[id] = transformToRenderedModule(mod);
	return result;
}

//#endregion
//#region src/utils/transform-to-rollup-output.ts
function transformToRollupSourceMap(map) {
	const parsed = JSON.parse(map);
	const obj = {
		...parsed,
		toString() {
			return JSON.stringify(obj);
		},
		toUrl() {
			return `data:application/json;charset=utf-8;base64,${node_buffer.Buffer.from(obj.toString(), "utf-8").toString("base64")}`;
		}
	};
	return obj;
}
function transformToRollupOutputChunk(bindingChunk, changed) {
	const chunk = {
		type: "chunk",
		get code() {
			return bindingChunk.code;
		},
		fileName: bindingChunk.fileName,
		name: bindingChunk.name,
		get modules() {
			return transformChunkModules(bindingChunk.modules);
		},
		get imports() {
			return bindingChunk.imports;
		},
		get dynamicImports() {
			return bindingChunk.dynamicImports;
		},
		exports: bindingChunk.exports,
		isEntry: bindingChunk.isEntry,
		facadeModuleId: bindingChunk.facadeModuleId || null,
		isDynamicEntry: bindingChunk.isDynamicEntry,
		get moduleIds() {
			return bindingChunk.moduleIds;
		},
		get map() {
			return bindingChunk.map ? transformToRollupSourceMap(bindingChunk.map) : null;
		},
		sourcemapFileName: bindingChunk.sourcemapFileName || null,
		preliminaryFileName: bindingChunk.preliminaryFileName
	};
	const cache = {};
	return new Proxy(chunk, {
		get(target, p) {
			if (p in cache) return cache[p];
			return target[p];
		},
		set(target, p, newValue) {
			cache[p] = newValue;
			changed?.updated.add(bindingChunk.fileName);
			return true;
		}
	});
}
function transformToRollupOutputAsset(bindingAsset, changed) {
	const asset = {
		type: "asset",
		fileName: bindingAsset.fileName,
		originalFileName: bindingAsset.originalFileName || null,
		originalFileNames: bindingAsset.originalFileNames,
		get source() {
			return transformAssetSource(bindingAsset.source);
		},
		name: bindingAsset.name ?? undefined,
		names: bindingAsset.names
	};
	const cache = {};
	return new Proxy(asset, {
		get(target, p) {
			if (p in cache) return cache[p];
			return target[p];
		},
		set(target, p, newValue) {
			cache[p] = newValue;
			changed?.updated.add(bindingAsset.fileName);
			return true;
		}
	});
}
function transformToRollupOutput(output, changed) {
	handleOutputErrors(output);
	const { chunks, assets } = output;
	return { output: [...chunks.map((chunk) => transformToRollupOutputChunk(chunk, changed)), ...assets.map((asset) => transformToRollupOutputAsset(asset, changed))] };
}
function handleOutputErrors(output) {
	const rawErrors = output.errors;
	if (rawErrors.length > 0) throw normalizeErrors(rawErrors);
}
function transformToOutputBundle(output, changed) {
	const bundle = Object.fromEntries(transformToRollupOutput(output, changed).output.map((item) => [item.fileName, item]));
	return new Proxy(bundle, { deleteProperty(target, property) {
		if (typeof property === "string") changed.deleted.add(property);
		return true;
	} });
}
function collectChangedBundle(changed, bundle) {
	const assets = [];
	const chunks = [];
	for (const key in bundle) {
		if (changed.deleted.has(key) || !changed.updated.has(key)) continue;
		const item = bundle[key];
		if (item.type === "asset") assets.push({
			filename: item.fileName,
			originalFileNames: item.originalFileNames,
			source: bindingAssetSource(item.source),
			names: item.names
		});
else chunks.push({
			code: item.code,
			filename: item.fileName,
			name: item.name,
			isEntry: item.isEntry,
			exports: item.exports,
			modules: {},
			imports: item.imports,
			dynamicImports: item.dynamicImports,
			facadeModuleId: item.facadeModuleId || undefined,
			isDynamicEntry: item.isDynamicEntry,
			moduleIds: item.moduleIds,
			map: bindingifySourcemap$1(item.map),
			sourcemapFilename: item.sourcemapFileName || undefined,
			preliminaryFilename: item.preliminaryFileName
		});
	}
	return {
		assets,
		chunks,
		deleted: Array.from(changed.deleted)
	};
}

//#endregion
//#region src/binding.js
var require_binding = require_chunk.__commonJS({ "src/binding.js"(exports, module) {
	const { createRequire } = require("node:module");
	require = createRequire(__filename);
	const { readFileSync } = require("node:fs");
	let nativeBinding = null;
	const loadErrors = [];
	const isMusl = () => {
		let musl = false;
		if (process.platform === "linux") {
			musl = isMuslFromFilesystem();
			if (musl === null) musl = isMuslFromReport();
			if (musl === null) musl = isMuslFromChildProcess();
		}
		return musl;
	};
	const isFileMusl = (f) => f.includes("libc.musl-") || f.includes("ld-musl-");
	const isMuslFromFilesystem = () => {
		try {
			return readFileSync("/usr/bin/ldd", "utf-8").includes("musl");
		} catch {
			return null;
		}
	};
	const isMuslFromReport = () => {
		const report = typeof process.report.getReport === "function" ? process.report.getReport() : null;
		if (!report) return null;
		if (report.header && report.header.glibcVersionRuntime) return false;
		if (Array.isArray(report.sharedObjects)) {
			if (report.sharedObjects.some(isFileMusl)) return true;
		}
		return false;
	};
	const isMuslFromChildProcess = () => {
		try {
			return require("child_process").execSync("ldd --version", { encoding: "utf8" }).includes("musl");
		} catch (e) {
			return false;
		}
	};
	function requireNative() {
		if (process.platform === "android") if (process.arch === "arm64") {
			try {
				return require("./rolldown-binding.android-arm64.node");
			} catch (e) {
				loadErrors.push(e);
			}
			try {
				return require("@rolldown/binding-android-arm64");
			} catch (e) {
				loadErrors.push(e);
			}
		} else if (process.arch === "arm") {
			try {
				return require("./rolldown-binding.android-arm-eabi.node");
			} catch (e) {
				loadErrors.push(e);
			}
			try {
				return require("@rolldown/binding-android-arm-eabi");
			} catch (e) {
				loadErrors.push(e);
			}
		} else loadErrors.push(new Error(`Unsupported architecture on Android ${process.arch}`));
else if (process.platform === "win32") if (process.arch === "x64") {
			try {
				return require("./rolldown-binding.win32-x64-msvc.node");
			} catch (e) {
				loadErrors.push(e);
			}
			try {
				return require("@rolldown/binding-win32-x64-msvc");
			} catch (e) {
				loadErrors.push(e);
			}
		} else if (process.arch === "ia32") {
			try {
				return require("./rolldown-binding.win32-ia32-msvc.node");
			} catch (e) {
				loadErrors.push(e);
			}
			try {
				return require("@rolldown/binding-win32-ia32-msvc");
			} catch (e) {
				loadErrors.push(e);
			}
		} else if (process.arch === "arm64") {
			try {
				return require("./rolldown-binding.win32-arm64-msvc.node");
			} catch (e) {
				loadErrors.push(e);
			}
			try {
				return require("@rolldown/binding-win32-arm64-msvc");
			} catch (e) {
				loadErrors.push(e);
			}
		} else loadErrors.push(new Error(`Unsupported architecture on Windows: ${process.arch}`));
else if (process.platform === "darwin") {
			try {
				return require("./rolldown-binding.darwin-universal.node");
			} catch (e) {
				loadErrors.push(e);
			}
			try {
				return require("@rolldown/binding-darwin-universal");
			} catch (e) {
				loadErrors.push(e);
			}
			if (process.arch === "x64") {
				try {
					return require("./rolldown-binding.darwin-x64.node");
				} catch (e) {
					loadErrors.push(e);
				}
				try {
					return require("@rolldown/binding-darwin-x64");
				} catch (e) {
					loadErrors.push(e);
				}
			} else if (process.arch === "arm64") {
				try {
					return require("./rolldown-binding.darwin-arm64.node");
				} catch (e) {
					loadErrors.push(e);
				}
				try {
					return require("@rolldown/binding-darwin-arm64");
				} catch (e) {
					loadErrors.push(e);
				}
			} else loadErrors.push(new Error(`Unsupported architecture on macOS: ${process.arch}`));
		} else if (process.platform === "freebsd") if (process.arch === "x64") {
			try {
				return require("./rolldown-binding.freebsd-x64.node");
			} catch (e) {
				loadErrors.push(e);
			}
			try {
				return require("@rolldown/binding-freebsd-x64");
			} catch (e) {
				loadErrors.push(e);
			}
		} else if (process.arch === "arm64") {
			try {
				return require("./rolldown-binding.freebsd-arm64.node");
			} catch (e) {
				loadErrors.push(e);
			}
			try {
				return require("@rolldown/binding-freebsd-arm64");
			} catch (e) {
				loadErrors.push(e);
			}
		} else loadErrors.push(new Error(`Unsupported architecture on FreeBSD: ${process.arch}`));
else if (process.platform === "linux") if (process.arch === "x64") if (isMusl()) {
			try {
				return require("./rolldown-binding.linux-x64-musl.node");
			} catch (e) {
				loadErrors.push(e);
			}
			try {
				return require("@rolldown/binding-linux-x64-musl");
			} catch (e) {
				loadErrors.push(e);
			}
		} else {
			try {
				return require("./rolldown-binding.linux-x64-gnu.node");
			} catch (e) {
				loadErrors.push(e);
			}
			try {
				return require("@rolldown/binding-linux-x64-gnu");
			} catch (e) {
				loadErrors.push(e);
			}
		}
else if (process.arch === "arm64") if (isMusl()) {
			try {
				return require("./rolldown-binding.linux-arm64-musl.node");
			} catch (e) {
				loadErrors.push(e);
			}
			try {
				return require("@rolldown/binding-linux-arm64-musl");
			} catch (e) {
				loadErrors.push(e);
			}
		} else {
			try {
				return require("./rolldown-binding.linux-arm64-gnu.node");
			} catch (e) {
				loadErrors.push(e);
			}
			try {
				return require("@rolldown/binding-linux-arm64-gnu");
			} catch (e) {
				loadErrors.push(e);
			}
		}
else if (process.arch === "arm") if (isMusl()) {
			try {
				return require("./rolldown-binding.linux-arm-musleabihf.node");
			} catch (e) {
				loadErrors.push(e);
			}
			try {
				return require("@rolldown/binding-linux-arm-musleabihf");
			} catch (e) {
				loadErrors.push(e);
			}
		} else {
			try {
				return require("./rolldown-binding.linux-arm-gnueabihf.node");
			} catch (e) {
				loadErrors.push(e);
			}
			try {
				return require("@rolldown/binding-linux-arm-gnueabihf");
			} catch (e) {
				loadErrors.push(e);
			}
		}
else if (process.arch === "riscv64") if (isMusl()) {
			try {
				return require("./rolldown-binding.linux-riscv64-musl.node");
			} catch (e) {
				loadErrors.push(e);
			}
			try {
				return require("@rolldown/binding-linux-riscv64-musl");
			} catch (e) {
				loadErrors.push(e);
			}
		} else {
			try {
				return require("./rolldown-binding.linux-riscv64-gnu.node");
			} catch (e) {
				loadErrors.push(e);
			}
			try {
				return require("@rolldown/binding-linux-riscv64-gnu");
			} catch (e) {
				loadErrors.push(e);
			}
		}
else if (process.arch === "ppc64") {
			try {
				return require("./rolldown-binding.linux-ppc64-gnu.node");
			} catch (e) {
				loadErrors.push(e);
			}
			try {
				return require("@rolldown/binding-linux-ppc64-gnu");
			} catch (e) {
				loadErrors.push(e);
			}
		} else if (process.arch === "s390x") {
			try {
				return require("./rolldown-binding.linux-s390x-gnu.node");
			} catch (e) {
				loadErrors.push(e);
			}
			try {
				return require("@rolldown/binding-linux-s390x-gnu");
			} catch (e) {
				loadErrors.push(e);
			}
		} else loadErrors.push(new Error(`Unsupported architecture on Linux: ${process.arch}`));
else loadErrors.push(new Error(`Unsupported OS: ${process.platform}, architecture: ${process.arch}`));
	}
	nativeBinding = requireNative();
	if (!nativeBinding || process.env.NAPI_RS_FORCE_WASI) {
		try {
			nativeBinding = require("./rolldown-binding.wasi.cjs");
		} catch (err) {
			if (process.env.NAPI_RS_FORCE_WASI) loadErrors.push(err);
		}
		if (!nativeBinding) try {
			nativeBinding = require("@rolldown/binding-wasm32-wasi");
		} catch (err) {
			if (process.env.NAPI_RS_FORCE_WASI) loadErrors.push(err);
		}
	}
	if (!nativeBinding) {
		if (loadErrors.length > 0) throw new Error("Failed to load native binding", { cause: loadErrors });
		throw new Error(`Failed to load native binding`);
	}
	module.exports.BindingBundleEndEventData = nativeBinding.BindingBundleEndEventData;
	module.exports.BindingCallableBuiltinPlugin = nativeBinding.BindingCallableBuiltinPlugin;
	module.exports.BindingError = nativeBinding.BindingError;
	module.exports.BindingLog = nativeBinding.BindingLog;
	module.exports.BindingModuleInfo = nativeBinding.BindingModuleInfo;
	module.exports.BindingNormalizedOptions = nativeBinding.BindingNormalizedOptions;
	module.exports.BindingOutputAsset = nativeBinding.BindingOutputAsset;
	module.exports.BindingOutputChunk = nativeBinding.BindingOutputChunk;
	module.exports.BindingOutputs = nativeBinding.BindingOutputs;
	module.exports.BindingPluginContext = nativeBinding.BindingPluginContext;
	module.exports.BindingRenderedModule = nativeBinding.BindingRenderedModule;
	module.exports.BindingTransformPluginContext = nativeBinding.BindingTransformPluginContext;
	module.exports.BindingWatcher = nativeBinding.BindingWatcher;
	module.exports.BindingWatcherChangeData = nativeBinding.BindingWatcherChangeData;
	module.exports.BindingWatcherEvent = nativeBinding.BindingWatcherEvent;
	module.exports.Bundler = nativeBinding.Bundler;
	module.exports.ParallelJsPluginRegistry = nativeBinding.ParallelJsPluginRegistry;
	module.exports.BindingBuiltinPluginName = nativeBinding.BindingBuiltinPluginName;
	module.exports.BindingHookSideEffects = nativeBinding.BindingHookSideEffects;
	module.exports.BindingLogLevel = nativeBinding.BindingLogLevel;
	module.exports.BindingPluginOrder = nativeBinding.BindingPluginOrder;
	module.exports.HelperMode = nativeBinding.HelperMode;
	module.exports.isolatedDeclaration = nativeBinding.isolatedDeclaration;
	module.exports.registerPlugins = nativeBinding.registerPlugins;
	module.exports.Severity = nativeBinding.Severity;
	module.exports.transform = nativeBinding.transform;
} });

//#endregion
//#region src/utils/misc.ts
function arraify(value) {
	return Array.isArray(value) ? value : [value];
}
function isNullish(value) {
	return value === null || value === undefined;
}
function unimplemented(info) {
	if (info) throw new Error(`unimplemented: ${info}`);
	throw new Error("unimplemented");
}
function unreachable(info) {
	if (info) throw new Error(`unreachable: ${info}`);
	throw new Error("unreachable");
}
function unsupported(info) {
	throw new Error(`UNSUPPORTED: ${info}`);
}
function noop(..._args) {}

//#endregion
//#region src/log/logging.ts
const LogLevelSchema = zod.z.literal("info").or(zod.z.literal("debug")).or(zod.z.literal("warn"));
const LogLevelOptionSchema = LogLevelSchema.or(zod.z.literal("silent"));
const LogLevelWithErrorSchema = LogLevelSchema.or(zod.z.literal("error"));
const LOG_LEVEL_SILENT = "silent";
const LOG_LEVEL_ERROR = "error";
const LOG_LEVEL_WARN = "warn";
const LOG_LEVEL_INFO = "info";
const LOG_LEVEL_DEBUG = "debug";
const logLevelPriority = {
	[LOG_LEVEL_DEBUG]: 0,
	[LOG_LEVEL_INFO]: 1,
	[LOG_LEVEL_WARN]: 2,
	[LOG_LEVEL_SILENT]: 3
};
const RollupLogSchema = zod.z.any();
const RollupLogWithStringSchema = RollupLogSchema.or(zod.z.string());

//#endregion
//#region src/utils/code-frame.ts
function spaces(index) {
	let result = "";
	while (index--) result += " ";
	return result;
}
function tabsToSpaces(value) {
	return value.replace(/^\t+/, (match) => match.split("	").join("  "));
}
const LINE_TRUNCATE_LENGTH = 120;
const MIN_CHARACTERS_SHOWN_AFTER_LOCATION = 10;
const ELLIPSIS = "...";
function getCodeFrame(source, line, column) {
	let lines = source.split("\n");
	if (line > lines.length) return "";
	const maxLineLength = Math.max(tabsToSpaces(lines[line - 1].slice(0, column)).length + MIN_CHARACTERS_SHOWN_AFTER_LOCATION + ELLIPSIS.length, LINE_TRUNCATE_LENGTH);
	const frameStart = Math.max(0, line - 3);
	let frameEnd = Math.min(line + 2, lines.length);
	lines = lines.slice(frameStart, frameEnd);
	while (!/\S/.test(lines[lines.length - 1])) {
		lines.pop();
		frameEnd -= 1;
	}
	const digits = String(frameEnd).length;
	return lines.map((sourceLine, index) => {
		const isErrorLine = frameStart + index + 1 === line;
		let lineNumber = String(index + frameStart + 1);
		while (lineNumber.length < digits) lineNumber = ` ${lineNumber}`;
		let displayedLine = tabsToSpaces(sourceLine);
		if (displayedLine.length > maxLineLength) displayedLine = `${displayedLine.slice(0, maxLineLength - ELLIPSIS.length)}${ELLIPSIS}`;
		if (isErrorLine) {
			const indicator = spaces(digits + 2 + tabsToSpaces(sourceLine.slice(0, column)).length) + "^";
			return `${lineNumber}: ${displayedLine}\n${indicator}`;
		}
		return `${lineNumber}: ${displayedLine}`;
	}).join("\n");
}

//#endregion
//#region src/log/locate-character/index.js
/** @typedef {import('./types').Location} Location */
/**
* @param {import('./types').Range} range
* @param {number} index
*/
function rangeContains(range, index) {
	return range.start <= index && index < range.end;
}
function getLocator(source, options = {}) {
	const { offsetLine = 0, offsetColumn = 0 } = options;
	let start = 0;
	const ranges = source.split("\n").map((line, i$1) => {
		const end = start + line.length + 1;
		/** @type {import('./types').Range} */
		const range = {
			start,
			end,
			line: i$1
		};
		start = end;
		return range;
	});
	let i = 0;
	/**
	* @param {string | number} search
	* @param {number} [index]
	* @returns {Location | undefined}
	*/
	function locator(search, index) {
		if (typeof search === "string") search = source.indexOf(search, index ?? 0);
		if (search === -1) return undefined;
		let range = ranges[i];
		const d = search >= range.end ? 1 : -1;
		while (range) {
			if (rangeContains(range, search)) return {
				line: offsetLine + range.line,
				column: offsetColumn + search - range.start,
				character: search
			};
			i += d;
			range = ranges[i];
		}
	}
	return locator;
}
function locate(source, search, options) {
	return getLocator(source, options)(search, options && options.startIndex);
}

//#endregion
//#region src/log/logs.ts
const INVALID_LOG_POSITION = "INVALID_LOG_POSITION", PLUGIN_ERROR = "PLUGIN_ERROR", INPUT_HOOK_IN_OUTPUT_PLUGIN = "INPUT_HOOK_IN_OUTPUT_PLUGIN", CYCLE_LOADING = "CYCLE_LOADING", MULTIPLY_NOTIFY_OPTION = "MULTIPLY_NOTIFY_OPTION", MINIFY_WARNING = "MINIFY_WARNING";
function logMinifyWarning() {
	return {
		code: MINIFY_WARNING,
		message: "The built-in minifier is still under development. Setting \"minify: true\" is not recommended for production use."
	};
}
function logInvalidLogPosition(pluginName) {
	return {
		code: INVALID_LOG_POSITION,
		message: `Plugin "${pluginName}" tried to add a file position to a log or warning. This is only supported in the "transform" hook at the moment and will be ignored.`
	};
}
function logInputHookInOutputPlugin(pluginName, hookName) {
	return {
		code: INPUT_HOOK_IN_OUTPUT_PLUGIN,
		message: `The "${hookName}" hook used by the output plugin ${pluginName} is a build time hook and will not be run for that plugin. Either this plugin cannot be used as an output plugin, or it should have an option to configure it as an output plugin.`
	};
}
function logCycleLoading(pluginName, moduleId) {
	return {
		code: CYCLE_LOADING,
		message: `Found the module "${moduleId}" cycle loading at ${pluginName} plugin, it maybe blocking fetching modules.`
	};
}
function logMultiplyNotifyOption() {
	return {
		code: MULTIPLY_NOTIFY_OPTION,
		message: `Found multiply notify option at watch options, using first one to start notify watcher.`
	};
}
function logPluginError(error$1, plugin, { hook, id } = {}) {
	const code = error$1.code;
	if (!error$1.pluginCode && code != null && (typeof code !== "string" || !code.startsWith("PLUGIN_"))) error$1.pluginCode = code;
	error$1.code = PLUGIN_ERROR;
	error$1.plugin = plugin;
	if (hook) error$1.hook = hook;
	if (id) error$1.id = id;
	return error$1;
}
function error(base) {
	if (!(base instanceof Error)) {
		base = Object.assign(new Error(base.message), base);
		Object.defineProperty(base, "name", {
			value: "RollupError",
			writable: true
		});
	}
	throw base;
}
function augmentCodeLocation(properties, pos, source, id) {
	if (typeof pos === "object") {
		const { line, column } = pos;
		properties.loc = {
			column,
			file: id,
			line
		};
	} else {
		properties.pos = pos;
		const location = locate(source, pos, { offsetLine: 1 });
		if (!location) return;
		const { line, column } = location;
		properties.loc = {
			column,
			file: id,
			line
		};
	}
	if (properties.frame === undefined) {
		const { line, column } = properties.loc;
		properties.frame = getCodeFrame(source, line, column);
	}
}

//#endregion
//#region src/log/logHandler.ts
const normalizeLog = (log) => typeof log === "string" ? { message: log } : typeof log === "function" ? normalizeLog(log()) : log;
function getLogHandler(level, code, logger, pluginName, logLevel) {
	if (logLevelPriority[level] < logLevelPriority[logLevel]) return noop;
	return (log, pos) => {
		if (pos != null) logger(LOG_LEVEL_WARN, logInvalidLogPosition(pluginName));
		log = normalizeLog(log);
		if (log.code && !log.pluginCode) log.pluginCode = log.code;
		log.code = code;
		log.plugin = pluginName;
		logger(level, log);
	};
}

//#endregion
//#region src/utils/normalize-hook.ts
function normalizeHook(hook) {
	if (typeof hook === "function" || typeof hook === "string") return {
		handler: hook,
		options: {},
		meta: {}
	};
	if (typeof hook === "object" && hook !== null) {
		const { handler, order,...options } = hook;
		return {
			handler,
			options,
			meta: { order }
		};
	}
	unreachable("Invalid hook type");
}

//#endregion
//#region src/log/logger.ts
function getLogger(plugins, onLog, logLevel) {
	const minimalPriority = logLevelPriority[logLevel];
	const logger = (level, log, skipped = new Set()) => {
		const logPriority = logLevelPriority[level];
		if (logPriority < minimalPriority) return;
		for (const plugin of getSortedPlugins("onLog", plugins)) {
			if (skipped.has(plugin)) continue;
			const { onLog: pluginOnLog } = plugin;
			if (pluginOnLog) {
				const getLogHandler$1 = (level$1) => {
					if (logLevelPriority[level$1] < minimalPriority) return () => {};
					return (log$1) => logger(level$1, normalizeLog(log$1), new Set(skipped).add(plugin));
				};
				const handler = "handler" in pluginOnLog ? pluginOnLog.handler : pluginOnLog;
				if (handler.call({
					debug: getLogHandler$1(LOG_LEVEL_DEBUG),
					error: (log$1) => error(normalizeLog(log$1)),
					info: getLogHandler$1(LOG_LEVEL_INFO),
					meta: {
						rollupVersion: "4.23.0",
						rolldownVersion: VERSION,
						watchMode: false
					},
					warn: getLogHandler$1(LOG_LEVEL_WARN),
					pluginName: plugin.name || "unknown"
				}, level, log) === false) return;
			}
		}
		onLog(level, log);
	};
	return logger;
}
const getOnLog = (config, logLevel, printLog = defaultPrintLog) => {
	const { onwarn, onLog } = config;
	const defaultOnLog = getDefaultOnLog(printLog, onwarn);
	if (onLog) {
		const minimalPriority = logLevelPriority[logLevel];
		return (level, log) => onLog(level, addLogToString(log), (level$1, handledLog) => {
			if (level$1 === LOG_LEVEL_ERROR) return error(normalizeLog(handledLog));
			if (logLevelPriority[level$1] >= minimalPriority) defaultOnLog(level$1, normalizeLog(handledLog));
		});
	}
	return defaultOnLog;
};
const getDefaultOnLog = (printLog, onwarn) => onwarn ? (level, log) => {
	if (level === LOG_LEVEL_WARN) onwarn(addLogToString(log), (warning) => printLog(LOG_LEVEL_WARN, normalizeLog(warning)));
else printLog(level, log);
} : printLog;
const addLogToString = (log) => {
	Object.defineProperty(log, "toString", {
		value: () => getExtendedLogMessage(log),
		writable: true
	});
	return log;
};
const defaultPrintLog = (level, log) => {
	const message = getExtendedLogMessage(log);
	switch (level) {
		case LOG_LEVEL_WARN: return console.warn(message);
		case LOG_LEVEL_DEBUG: return console.debug(message);
		default: return console.info(message);
	}
};
const getExtendedLogMessage = (log) => {
	let prefix = "";
	if (log.plugin) prefix += `(${log.plugin} plugin) `;
	if (log.loc) prefix += `${relativeId(log.loc.file)} (${log.loc.line}:${log.loc.column}) `;
	return prefix + log.message;
};
function relativeId(id) {
	if (!node_path.default.isAbsolute(id)) return id;
	return node_path.default.relative(node_path.default.resolve(), id);
}

//#endregion
//#region src/builtin-plugin/utils.ts
var import_binding$6 = require_chunk.__toESM(require_binding());
function makeBuiltinPluginCallable(plugin) {
	let callablePlugin = new import_binding$6.BindingCallableBuiltinPlugin(bindingifyBuiltInPlugin(plugin));
	const wrappedPlugin = plugin;
	for (const key in callablePlugin) wrappedPlugin[key] = function(...args) {
		return callablePlugin[key](...args);
	};
	return wrappedPlugin;
}
function bindingifyBuiltInPlugin(plugin) {
	return {
		__name: plugin.name,
		options: plugin._options
	};
}

//#endregion
//#region src/builtin-plugin/constructors.ts
var BuiltinPlugin = class {
	constructor(name, _options) {
		this.name = name;
		this._options = _options;
		this.name = name;
		this._options = _options;
	}
};
function modulePreloadPolyfillPlugin(config) {
	return new BuiltinPlugin("builtin:module-preload-polyfill", config);
}
function dynamicImportVarsPlugin() {
	return new BuiltinPlugin("builtin:dynamic-import-vars");
}
function importGlobPlugin(config) {
	return new BuiltinPlugin("builtin:import-glob", config);
}
function manifestPlugin(config) {
	return new BuiltinPlugin("builtin:manifest", config);
}
function wasmHelperPlugin() {
	return new BuiltinPlugin("builtin:wasm-helper");
}
function wasmFallbackPlugin() {
	return new BuiltinPlugin("builtin:wasm-fallback");
}
function loadFallbackPlugin() {
	return new BuiltinPlugin("builtin:load-fallback");
}
function jsonPlugin(config) {
	return new BuiltinPlugin("builtin:json", config);
}
function buildImportAnalysisPlugin(config) {
	return new BuiltinPlugin("builtin:build-import-analysis", config);
}
function viteResolvePlugin(config) {
	const builtinPlugin = new BuiltinPlugin("builtin:vite-resolve", {
		...config,
		runtime: process.versions.deno ? "deno" : process.versions.bun ? "bun" : "node"
	});
	return makeBuiltinPluginCallable(builtinPlugin);
}

//#endregion
//#region src/utils/async-flatten.ts
async function asyncFlatten(array) {
	do 
		array = (await Promise.all(array)).flat(Infinity);
	while (array.some((v) => v?.then));
	return array;
}

//#endregion
//#region src/constants/plugin.ts
const ENUMERATED_INPUT_PLUGIN_HOOK_NAMES = [
	"options",
	"buildStart",
	"resolveId",
	"load",
	"transform",
	"moduleParsed",
	"buildEnd",
	"onLog",
	"resolveDynamicImport",
	"closeBundle",
	"closeWatcher",
	"watchChange"
];
const ENUMERATED_OUTPUT_PLUGIN_HOOK_NAMES = [
	"augmentChunkHash",
	"outputOptions",
	"renderChunk",
	"renderStart",
	"renderError",
	"writeBundle",
	"generateBundle"
];
const ENUMERATED_PLUGIN_HOOK_NAMES = [
	...ENUMERATED_INPUT_PLUGIN_HOOK_NAMES,
	...ENUMERATED_OUTPUT_PLUGIN_HOOK_NAMES,
	"footer",
	"banner",
	"intro",
	"outro"
];
const DEFINED_HOOK_NAMES = {
	[ENUMERATED_PLUGIN_HOOK_NAMES[0]]: ENUMERATED_PLUGIN_HOOK_NAMES[0],
	[ENUMERATED_PLUGIN_HOOK_NAMES[1]]: ENUMERATED_PLUGIN_HOOK_NAMES[1],
	[ENUMERATED_PLUGIN_HOOK_NAMES[2]]: ENUMERATED_PLUGIN_HOOK_NAMES[2],
	[ENUMERATED_PLUGIN_HOOK_NAMES[3]]: ENUMERATED_PLUGIN_HOOK_NAMES[3],
	[ENUMERATED_PLUGIN_HOOK_NAMES[4]]: ENUMERATED_PLUGIN_HOOK_NAMES[4],
	[ENUMERATED_PLUGIN_HOOK_NAMES[5]]: ENUMERATED_PLUGIN_HOOK_NAMES[5],
	[ENUMERATED_PLUGIN_HOOK_NAMES[6]]: ENUMERATED_PLUGIN_HOOK_NAMES[6],
	[ENUMERATED_PLUGIN_HOOK_NAMES[7]]: ENUMERATED_PLUGIN_HOOK_NAMES[7],
	[ENUMERATED_PLUGIN_HOOK_NAMES[8]]: ENUMERATED_PLUGIN_HOOK_NAMES[8],
	[ENUMERATED_PLUGIN_HOOK_NAMES[9]]: ENUMERATED_PLUGIN_HOOK_NAMES[9],
	[ENUMERATED_PLUGIN_HOOK_NAMES[10]]: ENUMERATED_PLUGIN_HOOK_NAMES[10],
	[ENUMERATED_PLUGIN_HOOK_NAMES[11]]: ENUMERATED_PLUGIN_HOOK_NAMES[11],
	[ENUMERATED_PLUGIN_HOOK_NAMES[12]]: ENUMERATED_PLUGIN_HOOK_NAMES[12],
	[ENUMERATED_PLUGIN_HOOK_NAMES[13]]: ENUMERATED_PLUGIN_HOOK_NAMES[13],
	[ENUMERATED_PLUGIN_HOOK_NAMES[14]]: ENUMERATED_PLUGIN_HOOK_NAMES[14],
	[ENUMERATED_PLUGIN_HOOK_NAMES[15]]: ENUMERATED_PLUGIN_HOOK_NAMES[15],
	[ENUMERATED_PLUGIN_HOOK_NAMES[16]]: ENUMERATED_PLUGIN_HOOK_NAMES[16],
	[ENUMERATED_PLUGIN_HOOK_NAMES[17]]: ENUMERATED_PLUGIN_HOOK_NAMES[17],
	[ENUMERATED_PLUGIN_HOOK_NAMES[18]]: ENUMERATED_PLUGIN_HOOK_NAMES[18],
	[ENUMERATED_PLUGIN_HOOK_NAMES[19]]: ENUMERATED_PLUGIN_HOOK_NAMES[19],
	[ENUMERATED_PLUGIN_HOOK_NAMES[20]]: ENUMERATED_PLUGIN_HOOK_NAMES[20],
	[ENUMERATED_PLUGIN_HOOK_NAMES[21]]: ENUMERATED_PLUGIN_HOOK_NAMES[21],
	[ENUMERATED_PLUGIN_HOOK_NAMES[22]]: ENUMERATED_PLUGIN_HOOK_NAMES[22]
};

//#endregion
//#region src/utils/normalize-plugin-option.ts
const normalizePluginOption = async (plugins) => (await asyncFlatten([plugins])).filter(Boolean);
function checkOutputPluginOption(plugins, onLog) {
	for (const plugin of plugins) for (const hook of ENUMERATED_INPUT_PLUGIN_HOOK_NAMES) if (hook in plugin) {
		delete plugin[hook];
		onLog(LOG_LEVEL_WARN, logInputHookInOutputPlugin(plugin.name, hook));
	}
	return plugins;
}
function normalizePlugins(plugins, anonymousPrefix) {
	for (const [index, plugin] of plugins.entries()) {
		if ("_parallel" in plugin) continue;
		if (plugin instanceof BuiltinPlugin) continue;
		if (!plugin.name) plugin.name = `${anonymousPrefix}${index + 1}`;
	}
	return plugins;
}
const ANONYMOUS_PLUGIN_PREFIX = "at position ";
const ANONYMOUS_OUTPUT_PLUGIN_PREFIX = "at output position ";

//#endregion
//#region src/plugin/plugin-driver.ts
var PluginDriver = class {
	async callOptionsHook(inputOptions) {
		const logLevel = inputOptions.logLevel || LOG_LEVEL_INFO;
		const plugins = getSortedPlugins("options", getObjectPlugins(await normalizePluginOption(inputOptions.plugins)));
		const logger = getLogger(plugins, getOnLog(inputOptions, logLevel), logLevel);
		for (const plugin of plugins) {
			const name = plugin.name || "unknown";
			const options = plugin.options;
			if (options) {
				const { handler } = normalizeHook(options);
				const result = await handler.call({
					debug: getLogHandler(LOG_LEVEL_DEBUG, "PLUGIN_LOG", logger, name, logLevel),
					error: (e) => error(logPluginError(normalizeLog(e), name, { hook: "onLog" })),
					info: getLogHandler(LOG_LEVEL_INFO, "PLUGIN_LOG", logger, name, logLevel),
					meta: {
						rollupVersion: "4.23.0",
						rolldownVersion: VERSION,
						watchMode: false
					},
					warn: getLogHandler(LOG_LEVEL_WARN, "PLUGIN_WARNING", logger, name, logLevel),
					pluginName: name
				}, inputOptions);
				if (result) inputOptions = result;
			}
		}
		return inputOptions;
	}
	callOutputOptionsHook(rawPlugins, outputOptions) {
		const sortedPlugins = getSortedPlugins("outputOptions", getObjectPlugins(rawPlugins));
		for (const plugin of sortedPlugins) {
			const options = plugin.outputOptions;
			if (options) {
				const { handler } = normalizeHook(options);
				const result = handler.call(null, outputOptions);
				if (result) outputOptions = result;
			}
		}
		return outputOptions;
	}
};
function getObjectPlugins(plugins) {
	return plugins.filter((plugin) => {
		if (!plugin) return undefined;
		if ("_parallel" in plugin) return undefined;
		if (plugin instanceof BuiltinPlugin) return undefined;
		return plugin;
	});
}
function getSortedPlugins(hookName, plugins) {
	const pre = [];
	const normal = [];
	const post = [];
	for (const plugin of plugins) {
		const hook = plugin[hookName];
		if (hook) {
			if (typeof hook === "object") {
				if (hook.order === "pre") {
					pre.push(plugin);
					continue;
				}
				if (hook.order === "post") {
					post.push(plugin);
					continue;
				}
			}
			normal.push(plugin);
		}
	}
	return [
		...pre,
		...normal,
		...post
	];
}

//#endregion
//#region src/treeshake/module-side-effects.ts
const ModuleSideEffectsRuleSchema = zod.z.object({
	test: zod.z.instanceof(RegExp).optional(),
	external: zod.z.boolean().optional(),
	sideEffects: zod.z.boolean()
}).refine((data) => {
	return data.test !== undefined || data.external !== undefined;
}, "Either `test` or `external` should be set.");
const ModuleSideEffectsOptionSchema = zod.z.boolean().or(zod.z.array(ModuleSideEffectsRuleSchema)).or(zod.z.function().args(zod.z.string(), zod.z.boolean()).returns(zod.z.boolean().optional())).or(zod.z.literal("no-external"));
const TreeshakingOptionsSchema = zod.z.object({
	moduleSideEffects: ModuleSideEffectsOptionSchema.optional(),
	annotations: zod.z.boolean().optional()
}).passthrough().or(zod.z.boolean());

//#endregion
//#region src/utils/transform-sourcemap.ts
function isEmptySourcemapFiled(array) {
	if (!array) return true;
	if (array.length === 0 || !array[0]) return true;
	return false;
}
function normalizeTransformHookSourcemap(id, originalCode, rawMap) {
	if (!rawMap) return;
	let map = typeof rawMap === "object" ? rawMap : JSON.parse(rawMap);
	if (isEmptySourcemapFiled(map.sourcesContent)) map.sourcesContent = [originalCode];
	if (isEmptySourcemapFiled(map.sources) || map.sources && map.sources.length === 1 && map.sources[0] !== id) map.sources = [id];
	return map;
}

//#endregion
//#region src/utils/transform-module-info.ts
function transformModuleInfo(info, option) {
	return {
		get ast() {
			return unsupported("ModuleInfo#ast");
		},
		get code() {
			return info.code;
		},
		id: info.id,
		importers: info.importers,
		dynamicImporters: info.dynamicImporters,
		importedIds: info.importedIds,
		dynamicallyImportedIds: info.dynamicallyImportedIds,
		exports: info.exports,
		isEntry: info.isEntry,
		...option
	};
}

//#endregion
//#region src/plugin/minimal-plugin-context.ts
var MinimalPluginContext = class {
	info;
	warn;
	debug;
	meta;
	constructor(onLog, logLevel, pluginName) {
		this.pluginName = pluginName;
		this.debug = getLogHandler(LOG_LEVEL_DEBUG, "PLUGIN_LOG", onLog, pluginName, logLevel);
		this.info = getLogHandler(LOG_LEVEL_INFO, "PLUGIN_LOG", onLog, pluginName, logLevel);
		this.warn = getLogHandler(LOG_LEVEL_WARN, "PLUGIN_WARNING", onLog, pluginName, logLevel);
		this.meta = {
			rollupVersion: "4.23.0",
			rolldownVersion: VERSION,
			watchMode: false
		};
	}
	error(e) {
		return error(logPluginError(normalizeLog(e), this.pluginName));
	}
};

//#endregion
//#region src/utils/transform-side-effects.ts
var import_binding$5 = require_chunk.__toESM(require_binding());
function bindingifySideEffects(sideEffects) {
	switch (sideEffects) {
		case true: return import_binding$5.BindingHookSideEffects.True;
		case false: return import_binding$5.BindingHookSideEffects.False;
		case "no-treeshake": return import_binding$5.BindingHookSideEffects.NoTreeshake;
		case null:
		case undefined: return undefined;
		default: throw new Error(`Unexpected side effects: ${sideEffects}`);
	}
}

//#endregion
//#region src/plugin/plugin-context.ts
var PluginContext = class extends MinimalPluginContext {
	constructor(context, plugin, data, onLog, logLevel, currentLoadingModule) {
		super(onLog, logLevel, plugin.name);
		this.context = context;
		this.data = data;
		this.onLog = onLog;
		this.currentLoadingModule = currentLoadingModule;
	}
	async load(options) {
		const id = options.id;
		if (id === this.currentLoadingModule) this.onLog(LOG_LEVEL_WARN, logCycleLoading(this.pluginName, this.currentLoadingModule));
		const moduleInfo = this.data.getModuleInfo(id, this.context);
		if (moduleInfo && moduleInfo.code !== null) return moduleInfo;
		const rawOptions = {
			meta: options.meta || {},
			moduleSideEffects: options.moduleSideEffects || null
		};
		this.data.updateModuleOption(id, rawOptions);
		async function createLoadModulePromise(context, data) {
			const loadPromise = data.loadModulePromiseMap.get(id);
			if (loadPromise) return loadPromise;
			let resolveFn;
			const promise = new Promise((resolve, _) => {
				resolveFn = resolve;
			});
			data.loadModulePromiseMap.set(id, promise);
			try {
				await context.load(id, bindingifySideEffects(options.moduleSideEffects), resolveFn);
			} finally {
				data.loadModulePromiseMap.delete(id);
			}
			return promise;
		}
		await createLoadModulePromise(this.context, this.data);
		return this.data.getModuleInfo(id, this.context);
	}
	async resolve(source, importer, options) {
		let receipt = undefined;
		if (options != null) receipt = this.data.saveResolveOptions(options);
		const res = await this.context.resolve(source, importer, {
			custom: receipt,
			skipSelf: options?.skipSelf
		});
		if (receipt != null) this.data.removeSavedResolveOptions(receipt);
		if (res == null) return null;
		const info = this.data.getModuleOption(res.id) || {};
		return {
			...res,
			...info
		};
	}
	emitFile(file) {
		if (file.type !== "asset") return unimplemented("PluginContext.emitFile: only asset type is supported");
		return this.context.emitFile({
			...file,
			originalFileName: file.originalFileName || undefined,
			source: bindingAssetSource(file.source)
		});
	}
	getFileName(referenceId) {
		return this.context.getFileName(referenceId);
	}
	getModuleInfo(id) {
		return this.data.getModuleInfo(id, this.context);
	}
	getModuleIds() {
		return this.data.getModuleIds(this.context);
	}
	addWatchFile(id) {
		this.context.addWatchFile(id);
	}
	/**
	* @deprecated This rollup API won't be supported by rolldown. Using this API will cause runtime error.
	*/
	parse(_input, _options) {
		unsupported("`PluginContext#parse` is not supported by rolldown.");
	}
};

//#endregion
//#region src/plugin/transform-plugin-context.ts
var TransformPluginContext = class extends PluginContext {
	constructor(context, plugin, data, inner, moduleId, moduleSource, onLog, LogLevelOption) {
		super(context, plugin, data, onLog, LogLevelOption, moduleId);
		this.inner = inner;
		this.moduleId = moduleId;
		this.moduleSource = moduleSource;
		const getLogHandler$1 = (handler) => (log, pos) => {
			log = normalizeLog(log);
			if (pos) augmentCodeLocation(log, pos, moduleSource, moduleId);
			log.id = moduleId;
			log.hook = "transform";
			handler(log);
		};
		this.debug = getLogHandler$1(this.debug);
		this.warn = getLogHandler$1(this.warn);
		this.info = getLogHandler$1(this.info);
	}
	error(e, pos) {
		if (typeof e === "string") e = { message: e };
		if (pos) augmentCodeLocation(e, pos, this.moduleSource, this.moduleId);
		e.id = this.moduleId;
		e.hook = "transform";
		return error(logPluginError(normalizeLog(e), this.pluginName));
	}
	getCombinedSourcemap() {
		return JSON.parse(this.inner.getCombinedSourcemap());
	}
};

//#endregion
//#region src/plugin/bindingify-plugin-hook-meta.ts
var import_binding$4 = require_chunk.__toESM(require_binding());
function bindingifyPluginHookMeta(options) {
	return { order: bindingPluginOrder(options.order) };
}
function bindingPluginOrder(order) {
	switch (order) {
		case "post": return import_binding$4.BindingPluginOrder.Post;
		case "pre": return import_binding$4.BindingPluginOrder.Pre;
		case null:
		case undefined: return undefined;
		default: throw new Error(`Unknown plugin order: ${order}`);
	}
}

//#endregion
//#region src/constants/plugin-context.ts
const SYMBOL_FOR_RESOLVE_CALLER_THAT_SKIP_SELF = Symbol("plugin-context-resolve-caller");

//#endregion
//#region src/plugin/bindingify-hook-filter.ts
function bindingifyStringFilter(matcher) {
	if (typeof matcher === "string" || matcher instanceof RegExp) return { include: [matcher] };
	if (Array.isArray(matcher)) return { include: matcher };
	return {
		include: matcher.include ? arraify(matcher.include) : undefined,
		exclude: matcher.exclude ? arraify(matcher.exclude) : undefined
	};
}
function bindingifyResolveIdFilter(filterOption) {
	return filterOption?.id ? bindingifyStringFilter(filterOption.id) : undefined;
}
function bindingifyLoadFilter(filterOption) {
	return filterOption?.id ? bindingifyStringFilter(filterOption.id) : undefined;
}
function bindingifyTransformFilter(filterOption) {
	if (!filterOption) return undefined;
	const { id, code, moduleType } = filterOption;
	let moduleTypeRet;
	if (moduleType) if (Array.isArray(moduleType)) moduleTypeRet = moduleType;
else moduleTypeRet = moduleType.include;
	return {
		id: id ? bindingifyStringFilter(id) : undefined,
		code: code ? bindingifyStringFilter(code) : undefined,
		moduleType: moduleTypeRet
	};
}

//#endregion
//#region src/options/normalized-input-options.ts
var NormalizedInputOptionsImpl = class {
	inner;
	constructor(inner, onLog) {
		this.onLog = onLog;
		this.inner = inner;
	}
	get shimMissingExports() {
		return this.inner.shimMissingExports;
	}
	get input() {
		return this.inner.input;
	}
	get cwd() {
		return this.inner.cwd ?? undefined;
	}
	get platform() {
		return this.inner.platform;
	}
};

//#endregion
//#region src/plugin/bindingify-build-hooks.ts
function bindingifyBuildStart(args) {
	const hook = args.plugin.buildStart;
	if (!hook) return {};
	const { handler, meta } = normalizeHook(hook);
	return {
		plugin: async (ctx, opts) => {
			await handler.call(new PluginContext(ctx, args.plugin, args.pluginContextData, args.onLog, args.logLevel), new NormalizedInputOptionsImpl(opts, args.onLog));
		},
		meta: bindingifyPluginHookMeta(meta)
	};
}
function bindingifyBuildEnd(args) {
	const hook = args.plugin.buildEnd;
	if (!hook) return {};
	const { handler, meta } = normalizeHook(hook);
	return {
		plugin: async (ctx, err) => {
			await handler.call(new PluginContext(ctx, args.plugin, args.pluginContextData, args.onLog, args.logLevel), err ? normalizeErrors(err) : undefined);
		},
		meta: bindingifyPluginHookMeta(meta)
	};
}
function bindingifyResolveId(args) {
	const hook = args.plugin.resolveId;
	if (!hook) return {};
	const { handler, meta, options } = normalizeHook(hook);
	return {
		plugin: async (ctx, specifier, importer, extraOptions) => {
			const contextResolveOptions = extraOptions.custom != null ? args.pluginContextData.getSavedResolveOptions(extraOptions.custom) : undefined;
			const newExtraOptions = {
				...extraOptions,
				custom: contextResolveOptions?.custom,
				[SYMBOL_FOR_RESOLVE_CALLER_THAT_SKIP_SELF]: contextResolveOptions?.[SYMBOL_FOR_RESOLVE_CALLER_THAT_SKIP_SELF]
			};
			const ret = await handler.call(new PluginContext(ctx, args.plugin, args.pluginContextData, args.onLog, args.logLevel), specifier, importer ?? undefined, newExtraOptions);
			if (ret == null) return;
			if (ret === false) return {
				id: specifier,
				external: true
			};
			if (typeof ret === "string") return { id: ret };
			args.pluginContextData.updateModuleOption(ret.id, {
				meta: ret.meta || {},
				moduleSideEffects: ret.moduleSideEffects || null
			});
			return {
				id: ret.id,
				external: ret.external,
				sideEffects: bindingifySideEffects(ret.moduleSideEffects)
			};
		},
		meta: bindingifyPluginHookMeta(meta),
		filter: bindingifyResolveIdFilter(options.filter)
	};
}
function bindingifyResolveDynamicImport(args) {
	const hook = args.plugin.resolveDynamicImport;
	if (!hook) return {};
	const { handler, meta } = normalizeHook(hook);
	return {
		plugin: async (ctx, specifier, importer) => {
			const ret = await handler.call(new PluginContext(ctx, args.plugin, args.pluginContextData, args.onLog, args.logLevel), specifier, importer ?? undefined);
			if (ret == null) return;
			if (ret === false) return {
				id: specifier,
				external: true
			};
			if (typeof ret === "string") return { id: ret };
			const result = {
				id: ret.id,
				external: ret.external
			};
			if (ret.moduleSideEffects !== null) result.sideEffects = bindingifySideEffects(ret.moduleSideEffects);
			args.pluginContextData.updateModuleOption(ret.id, {
				meta: ret.meta || {},
				moduleSideEffects: ret.moduleSideEffects || null
			});
			return result;
		},
		meta: bindingifyPluginHookMeta(meta)
	};
}
function bindingifyTransform(args) {
	const hook = args.plugin.transform;
	if (!hook) return {};
	const { handler, meta, options } = normalizeHook(hook);
	return {
		plugin: async (ctx, code, id, meta$1) => {
			const ret = await handler.call(new TransformPluginContext(ctx.inner(), args.plugin, args.pluginContextData, ctx, id, code, args.onLog, args.logLevel), code, id, meta$1);
			if (ret == null) return undefined;
			if (typeof ret === "string") return { code: ret };
			args.pluginContextData.updateModuleOption(id, {
				meta: ret.meta || {},
				moduleSideEffects: ret.moduleSideEffects || null
			});
			return {
				code: ret.code,
				map: bindingifySourcemap$1(normalizeTransformHookSourcemap(id, code, ret.map)),
				sideEffects: bindingifySideEffects(ret.moduleSideEffects),
				moduleType: ret.moduleType
			};
		},
		meta: bindingifyPluginHookMeta(meta),
		filter: bindingifyTransformFilter(options.filter)
	};
}
function bindingifyLoad(args) {
	const hook = args.plugin.load;
	if (!hook) return {};
	const { handler, meta, options } = normalizeHook(hook);
	return {
		plugin: async (ctx, id) => {
			const ret = await handler.call(new PluginContext(ctx, args.plugin, args.pluginContextData, args.onLog, args.logLevel, id), id);
			if (ret == null) return;
			if (typeof ret === "string") return { code: ret };
			args.pluginContextData.updateModuleOption(id, {
				meta: ret.meta || {},
				moduleSideEffects: ret.moduleSideEffects || null
			});
			let map = preProcessSourceMap(ret, id);
			return {
				code: ret.code,
				map: bindingifySourcemap$1(map),
				moduleType: ret.moduleType,
				sideEffects: bindingifySideEffects(ret.moduleSideEffects)
			};
		},
		meta: bindingifyPluginHookMeta(meta),
		filter: bindingifyLoadFilter(options.filter)
	};
}
function preProcessSourceMap(ret, id) {
	if (!ret.map) return;
	let map = typeof ret.map === "object" ? ret.map : JSON.parse(ret.map);
	if (!isEmptySourcemapFiled(map.sources)) {
		const directory = node_path.default.dirname(id) || ".";
		const sourceRoot = map.sourceRoot || ".";
		map.sources = map.sources.map((source) => node_path.default.resolve(directory, sourceRoot, source));
	}
	return map;
}
function bindingifyModuleParsed(args) {
	const hook = args.plugin.moduleParsed;
	if (!hook) return {};
	const { handler, meta } = normalizeHook(hook);
	return {
		plugin: async (ctx, moduleInfo) => {
			await handler.call(new PluginContext(ctx, args.plugin, args.pluginContextData, args.onLog, args.logLevel), transformModuleInfo(moduleInfo, args.pluginContextData.getModuleOption(moduleInfo.id)));
		},
		meta: bindingifyPluginHookMeta(meta)
	};
}

//#endregion
//#region src/options/normalized-output-options.ts
function mapFunctionOption(option, name) {
	return typeof option === "undefined" ? () => {
		unsupported(`You should not take \`NormalizedOutputOptions#${name}\` and call it directly`);
	} : option;
}
var NormalizedOutputOptionsImpl = class {
	inner;
	constructor(inner) {
		this.inner = inner;
	}
	get dir() {
		return this.inner.dir ?? undefined;
	}
	get entryFileNames() {
		return mapFunctionOption(this.inner.entryFilenames, "entryFileNames");
	}
	get chunkFileNames() {
		return mapFunctionOption(this.inner.chunkFilenames, "chunkFileNames");
	}
	get assetFileNames() {
		return this.inner.assetFilenames;
	}
	get format() {
		return this.inner.format;
	}
	get exports() {
		return this.inner.exports;
	}
	get sourcemap() {
		return this.inner.sourcemap;
	}
	get cssEntryFileNames() {
		return mapFunctionOption(this.inner.cssEntryFilenames, "cssEntryFileNames");
	}
	get cssChunkFileNames() {
		return mapFunctionOption(this.inner.cssChunkFilenames, "cssChunkFileNames");
	}
	get shimMissingExports() {
		return this.inner.shimMissingExports;
	}
	get name() {
		return this.inner.name ?? undefined;
	}
	get file() {
		return this.inner.file ?? undefined;
	}
	get inlineDynamicImports() {
		return this.inner.inlineDynamicImports;
	}
	get externalLiveBindings() {
		return this.inner.externalLiveBindings;
	}
	get banner() {
		return mapFunctionOption(this.inner.banner, "banner") ?? undefined;
	}
	get footer() {
		return mapFunctionOption(this.inner.footer, "footer") ?? undefined;
	}
	get intro() {
		return mapFunctionOption(this.inner.intro, "intro") ?? undefined;
	}
	get outro() {
		return mapFunctionOption(this.inner.outro, "outro") ?? undefined;
	}
	get esModule() {
		return this.inner.esModule;
	}
	get extend() {
		return this.inner.extend;
	}
	get globals() {
		return mapFunctionOption(this.inner.globals, "globals");
	}
	get hashCharacters() {
		return this.inner.hashCharacters;
	}
	get sourcemapDebugIds() {
		return this.inner.sourcemapDebugIds;
	}
	get sourcemapIgnoreList() {
		return mapFunctionOption(void 0, "sourcemapIgnoreList");
	}
	get sourcemapPathTransform() {
		return mapFunctionOption(void 0, "sourcemapPathTransform");
	}
	get minify() {
		return this.inner.minify;
	}
	get comments() {
		return this.inner.comments;
	}
	get polyfillRequire() {
		return this.inner.polyfillRequire;
	}
};

//#endregion
//#region src/plugin/bindingify-output-hooks.ts
function bindingifyRenderStart(args) {
	const hook = args.plugin.renderStart;
	if (!hook) return {};
	const { handler, meta } = normalizeHook(hook);
	return {
		plugin: async (ctx, opts) => {
			handler.call(new PluginContext(ctx, args.plugin, args.pluginContextData, args.onLog, args.logLevel), new NormalizedOutputOptionsImpl(opts), new NormalizedInputOptionsImpl(opts, args.onLog));
		},
		meta: bindingifyPluginHookMeta(meta)
	};
}
function bindingifyRenderChunk(args) {
	const hook = args.plugin.renderChunk;
	if (!hook) return {};
	const { handler, meta } = normalizeHook(hook);
	return {
		plugin: async (ctx, code, chunk, opts) => {
			const ret = await handler.call(new PluginContext(ctx, args.plugin, args.pluginContextData, args.onLog, args.logLevel), code, transformRenderedChunk(chunk), new NormalizedOutputOptionsImpl(opts));
			if (ret == null) return;
			if (typeof ret === "string") return { code: ret };
			if (!ret.map) return { code: ret.code };
			return {
				code: ret.code,
				map: bindingifySourcemap$1(ret.map)
			};
		},
		meta: bindingifyPluginHookMeta(meta)
	};
}
function bindingifyAugmentChunkHash(args) {
	const hook = args.plugin.augmentChunkHash;
	if (!hook) return {};
	const { handler, meta } = normalizeHook(hook);
	return {
		plugin: async (ctx, chunk) => {
			return await handler.call(new PluginContext(ctx, args.plugin, args.pluginContextData, args.onLog, args.logLevel), transformRenderedChunk(chunk));
		},
		meta: bindingifyPluginHookMeta(meta)
	};
}
function bindingifyRenderError(args) {
	const hook = args.plugin.renderError;
	if (!hook) return {};
	const { handler, meta } = normalizeHook(hook);
	return {
		plugin: async (ctx, err) => {
			handler.call(new PluginContext(ctx, args.plugin, args.pluginContextData, args.onLog, args.logLevel), normalizeErrors(err));
		},
		meta: bindingifyPluginHookMeta(meta)
	};
}
function bindingifyGenerateBundle(args) {
	const hook = args.plugin.generateBundle;
	if (!hook) return {};
	const { handler, meta } = normalizeHook(hook);
	return {
		plugin: async (ctx, bundle, isWrite, opts) => {
			const changed = {
				updated: new Set(),
				deleted: new Set()
			};
			const output = transformToOutputBundle(bundle, changed);
			await handler.call(new PluginContext(ctx, args.plugin, args.pluginContextData, args.onLog, args.logLevel), new NormalizedOutputOptionsImpl(opts), output, isWrite);
			return collectChangedBundle(changed, output);
		},
		meta: bindingifyPluginHookMeta(meta)
	};
}
function bindingifyWriteBundle(args) {
	const hook = args.plugin.writeBundle;
	if (!hook) return {};
	const { handler, meta } = normalizeHook(hook);
	return {
		plugin: async (ctx, bundle, opts) => {
			const changed = {
				updated: new Set(),
				deleted: new Set()
			};
			const output = transformToOutputBundle(bundle, changed);
			await handler.call(new PluginContext(ctx, args.plugin, args.pluginContextData, args.onLog, args.logLevel), new NormalizedOutputOptionsImpl(opts), output);
			return collectChangedBundle(changed, output);
		},
		meta: bindingifyPluginHookMeta(meta)
	};
}
function bindingifyCloseBundle(args) {
	const hook = args.plugin.closeBundle;
	if (!hook) return {};
	const { handler, meta } = normalizeHook(hook);
	return {
		plugin: async (ctx) => {
			await handler.call(new PluginContext(ctx, args.plugin, args.pluginContextData, args.onLog, args.logLevel));
		},
		meta: bindingifyPluginHookMeta(meta)
	};
}
function bindingifyBanner(args) {
	const hook = args.plugin.banner;
	if (!hook) return {};
	const { handler, meta } = normalizeHook(hook);
	return {
		plugin: async (ctx, chunk) => {
			if (typeof handler === "string") return handler;
			return handler.call(new PluginContext(ctx, args.plugin, args.pluginContextData, args.onLog, args.logLevel), transformRenderedChunk(chunk));
		},
		meta: bindingifyPluginHookMeta(meta)
	};
}
function bindingifyFooter(args) {
	const hook = args.plugin.footer;
	if (!hook) return {};
	const { handler, meta } = normalizeHook(hook);
	return {
		plugin: async (ctx, chunk) => {
			if (typeof handler === "string") return handler;
			return handler.call(new PluginContext(ctx, args.plugin, args.pluginContextData, args.onLog, args.logLevel), transformRenderedChunk(chunk));
		},
		meta: bindingifyPluginHookMeta(meta)
	};
}
function bindingifyIntro(args) {
	const hook = args.plugin.intro;
	if (!hook) return {};
	const { handler, meta } = normalizeHook(hook);
	return {
		plugin: async (ctx, chunk) => {
			if (typeof handler === "string") return handler;
			return handler.call(new PluginContext(ctx, args.plugin, args.pluginContextData, args.onLog, args.logLevel), transformRenderedChunk(chunk));
		},
		meta: bindingifyPluginHookMeta(meta)
	};
}
function bindingifyOutro(args) {
	const hook = args.plugin.outro;
	if (!hook) return {};
	const { handler, meta } = normalizeHook(hook);
	return {
		plugin: async (ctx, chunk) => {
			if (typeof handler === "string") return handler;
			return handler.call(new PluginContext(ctx, args.plugin, args.pluginContextData, args.onLog, args.logLevel), transformRenderedChunk(chunk));
		},
		meta: bindingifyPluginHookMeta(meta)
	};
}

//#endregion
//#region src/plugin/bindingify-watch-hooks.ts
function bindingifyWatchChange(args) {
	const hook = args.plugin.watchChange;
	if (!hook) return {};
	const { handler, meta } = normalizeHook(hook);
	return {
		plugin: async (ctx, id, event) => {
			await handler.call(new PluginContext(ctx, args.plugin, args.pluginContextData, args.onLog, args.logLevel), id, { event });
		},
		meta: bindingifyPluginHookMeta(meta)
	};
}
function bindingifyCloseWatcher(args) {
	const hook = args.plugin.closeWatcher;
	if (!hook) return {};
	const { handler, meta } = normalizeHook(hook);
	return {
		plugin: async (ctx) => {
			await handler.call(new PluginContext(ctx, args.plugin, args.pluginContextData, args.onLog, args.logLevel));
		},
		meta: bindingifyPluginHookMeta(meta)
	};
}

//#endregion
//#region src/plugin/bindingify-plugin.ts
function bindingifyPlugin(plugin, options, outputOptions, pluginContextData, onLog, logLevel) {
	const args = {
		plugin,
		options,
		outputOptions,
		pluginContextData,
		onLog,
		logLevel
	};
	const { plugin: buildStart, meta: buildStartMeta } = bindingifyBuildStart(args);
	const { plugin: resolveId, meta: resolveIdMeta, filter: resolveIdFilter } = bindingifyResolveId(args);
	const { plugin: resolveDynamicImport, meta: resolveDynamicImportMeta } = bindingifyResolveDynamicImport(args);
	const { plugin: buildEnd, meta: buildEndMeta } = bindingifyBuildEnd(args);
	const { plugin: transform, meta: transformMeta, filter: transformFilter } = bindingifyTransform(args);
	const { plugin: moduleParsed, meta: moduleParsedMeta } = bindingifyModuleParsed(args);
	const { plugin: load, meta: loadMeta, filter: loadFilter } = bindingifyLoad(args);
	const { plugin: renderChunk, meta: renderChunkMeta } = bindingifyRenderChunk(args);
	const { plugin: augmentChunkHash, meta: augmentChunkHashMeta } = bindingifyAugmentChunkHash(args);
	const { plugin: renderStart, meta: renderStartMeta } = bindingifyRenderStart(args);
	const { plugin: renderError, meta: renderErrorMeta } = bindingifyRenderError(args);
	const { plugin: generateBundle, meta: generateBundleMeta } = bindingifyGenerateBundle(args);
	const { plugin: writeBundle, meta: writeBundleMeta } = bindingifyWriteBundle(args);
	const { plugin: closeBundle, meta: closeBundleMeta } = bindingifyCloseBundle(args);
	const { plugin: banner, meta: bannerMeta } = bindingifyBanner(args);
	const { plugin: footer, meta: footerMeta } = bindingifyFooter(args);
	const { plugin: intro, meta: introMeta } = bindingifyIntro(args);
	const { plugin: outro, meta: outroMeta } = bindingifyOutro(args);
	const { plugin: watchChange, meta: watchChangeMeta } = bindingifyWatchChange(args);
	const { plugin: closeWatcher, meta: closeWatcherMeta } = bindingifyCloseWatcher(args);
	const result = {
		name: plugin.name,
		buildStart,
		buildStartMeta,
		resolveId,
		resolveIdMeta,
		resolveIdFilter,
		resolveDynamicImport,
		resolveDynamicImportMeta,
		buildEnd,
		buildEndMeta,
		transform,
		transformMeta,
		transformFilter,
		moduleParsed,
		moduleParsedMeta,
		load,
		loadMeta,
		loadFilter,
		renderChunk,
		renderChunkMeta,
		augmentChunkHash,
		augmentChunkHashMeta,
		renderStart,
		renderStartMeta,
		renderError,
		renderErrorMeta,
		generateBundle,
		generateBundleMeta,
		writeBundle,
		writeBundleMeta,
		closeBundle,
		closeBundleMeta,
		banner,
		bannerMeta,
		footer,
		footerMeta,
		intro,
		introMeta,
		outro,
		outroMeta,
		watchChange,
		watchChangeMeta,
		closeWatcher,
		closeWatcherMeta
	};
	return wrapHandlers(result);
}
function wrapHandlers(plugin) {
	for (const hookName of [
		"buildStart",
		"resolveId",
		"resolveDynamicImport",
		"buildEnd",
		"transform",
		"moduleParsed",
		"load",
		"renderChunk",
		"augmentChunkHash",
		"renderStart",
		"renderError",
		"generateBundle",
		"writeBundle",
		"closeBundle",
		"banner",
		"footer",
		"intro",
		"outro",
		"watchChange",
		"closeWatcher"
	]) {
		const handler = plugin[hookName];
		if (handler) plugin[hookName] = async (...args) => {
			try {
				return await handler(...args);
			} catch (e) {
				return error(logPluginError(e, plugin.name, {
					hook: hookName,
					id: hookName === "transform" ? args[2] : undefined
				}));
			}
		};
	}
	return plugin;
}

//#endregion
//#region src/plugin/plugin-context-data.ts
var PluginContextData = class {
	moduleOptionMap = new Map();
	resolveOptionsMap = new Map();
	loadModulePromiseMap = new Map();
	updateModuleOption(id, option) {
		const existing = this.moduleOptionMap.get(id);
		if (existing) {
			if (option.moduleSideEffects != null) existing.moduleSideEffects = option.moduleSideEffects;
			if (option.meta != null) Object.assign(existing.meta, option.meta);
		} else this.moduleOptionMap.set(id, option);
	}
	getModuleOption(id) {
		const option = this.moduleOptionMap.get(id);
		if (!option) {
			const raw = {
				moduleSideEffects: null,
				meta: {}
			};
			this.moduleOptionMap.set(id, raw);
			return raw;
		}
		return option;
	}
	getModuleInfo(id, context) {
		const bindingInfo = context.getModuleInfo(id);
		if (bindingInfo) {
			const info = transformModuleInfo(bindingInfo, this.getModuleOption(id));
			return info;
		}
		return null;
	}
	getModuleIds(context) {
		const moduleIds = context.getModuleIds();
		return moduleIds.values();
	}
	saveResolveOptions(options) {
		const index = this.resolveOptionsMap.size;
		this.resolveOptionsMap.set(index, options);
		return index;
	}
	getSavedResolveOptions(receipt) {
		return this.resolveOptionsMap.get(receipt);
	}
	removeSavedResolveOptions(receipt) {
		this.resolveOptionsMap.delete(receipt);
	}
};

//#endregion
//#region src/utils/normalize-string-or-regex.ts
function normalizedStringOrRegex(pattern) {
	if (!pattern) return undefined;
	if (!Array.isArray(pattern)) pattern = [pattern];
	return pattern;
}

//#endregion
//#region src/utils/bindingify-input-options.ts
var import_binding$3 = require_chunk.__toESM(require_binding());
function bindingifyInputOptions(rawPlugins, inputOptions, outputOptions, onLog, logLevel) {
	const pluginContextData = new PluginContextData();
	const plugins = rawPlugins.map((plugin) => {
		if ("_parallel" in plugin) return undefined;
		if (plugin instanceof BuiltinPlugin) return bindingifyBuiltInPlugin(plugin);
		return bindingifyPlugin(plugin, inputOptions, outputOptions, pluginContextData, onLog, logLevel);
	});
	return {
		input: bindingifyInput(inputOptions.input),
		plugins,
		cwd: inputOptions.cwd ?? process.cwd(),
		external: bindingifyExternal(inputOptions.external),
		resolve: bindingifyResolve(inputOptions.resolve),
		platform: inputOptions.platform,
		shimMissingExports: inputOptions.shimMissingExports,
		logLevel: bindingifyLogLevel(logLevel),
		onLog,
		treeshake: bindingifyTreeshakeOptions(inputOptions.treeshake),
		moduleTypes: inputOptions.moduleTypes,
		define: inputOptions.define ? Object.entries(inputOptions.define) : undefined,
		inject: bindingifyInject(inputOptions.inject),
		experimental: {
			strictExecutionOrder: inputOptions.experimental?.strictExecutionOrder,
			disableLiveBindings: inputOptions.experimental?.disableLiveBindings,
			viteMode: inputOptions.experimental?.viteMode,
			resolveNewUrlToAsset: inputOptions.experimental?.resolveNewUrlToAsset
		},
		profilerNames: inputOptions?.profilerNames,
		jsx: bindingifyJsx(inputOptions.jsx),
		watch: bindingifyWatch(inputOptions.watch),
		dropLabels: inputOptions.dropLabels,
		keepNames: inputOptions.keepNames,
		checks: inputOptions.checks
	};
}
function bindingifyExternal(external) {
	if (external) {
		if (typeof external === "function") return (id, importer, isResolved) => {
			if (id.startsWith("\0")) return false;
			return external(id, importer, isResolved) ?? false;
		};
		const externalArr = arraify(external);
		return (id, _importer, _isResolved) => {
			return externalArr.some((pat) => {
				if (pat instanceof RegExp) return pat.test(id);
				return id === pat;
			});
		};
	}
}
function bindingifyResolve(resolve) {
	if (resolve) {
		const { alias, extensionAlias,...rest } = resolve;
		return {
			alias: alias ? Object.entries(alias).map(([name, replacement]) => ({
				find: name,
				replacements: arraify(replacement)
			})) : undefined,
			extensionAlias: extensionAlias ? Object.entries(extensionAlias).map(([name, value]) => ({
				target: name,
				replacements: value
			})) : undefined,
			...rest
		};
	}
}
function bindingifyInject(inject) {
	if (inject) return Object.entries(inject).map(([alias, item]) => {
		if (Array.isArray(item)) {
			if (item[1] === "*") return {
				tagNamespace: true,
				alias,
				from: item[0]
			};
			return {
				tagNamed: true,
				alias,
				from: item[0],
				imported: item[1]
			};
		} else return {
			tagNamed: true,
			imported: "default",
			alias,
			from: item
		};
	});
}
function bindingifyLogLevel(logLevel) {
	switch (logLevel) {
		case "silent": return import_binding$3.BindingLogLevel.Silent;
		case "debug": return import_binding$3.BindingLogLevel.Debug;
		case "warn": return import_binding$3.BindingLogLevel.Warn;
		case "info": return import_binding$3.BindingLogLevel.Info;
		default: throw new Error(`Unexpected log level: ${logLevel}`);
	}
}
function bindingifyInput(input) {
	if (input === undefined) return [];
	if (typeof input === "string") return [{ import: input }];
	if (Array.isArray(input)) return input.map((src) => ({ import: src }));
	return Object.entries(input).map((value) => {
		return {
			name: value[0],
			import: value[1]
		};
	});
}
function bindingifyJsx(input) {
	if (input === false) return { type: "Disable" };
	if (input) {
		if (input.mode === "preserve") return { type: "Preserve" };
		const mode = input.mode ?? "automatic";
		return {
			type: "Enable",
			field0: {
				runtime: mode,
				importSource: mode === "classic" ? input.importSource : mode === "automatic" ? input.jsxImportSource : undefined,
				pragma: input.factory,
				pragmaFrag: input.fragment,
				development: input.development,
				refresh: input.refresh
			}
		};
	}
}
function bindingifyWatch(watch$1) {
	if (watch$1) {
		let value = {
			skipWrite: watch$1.skipWrite,
			include: normalizedStringOrRegex(watch$1.include),
			exclude: normalizedStringOrRegex(watch$1.exclude)
		};
		if (watch$1.chokidar) unsupported("The watch chokidar option is deprecated, please use notify options instead of it.");
		return value;
	}
}
function bindingifyTreeshakeOptions(config) {
	if (config === false) return undefined;
	if (config === true || config === undefined) return {
		moduleSideEffects: true,
		annotations: true
	};
	let normalizedConfig = { moduleSideEffects: true };
	if (config.moduleSideEffects === undefined) normalizedConfig.moduleSideEffects = true;
else if (config.moduleSideEffects === "no-external") normalizedConfig.moduleSideEffects = [{
		external: true,
		sideEffects: false
	}, {
		external: false,
		sideEffects: true
	}];
else normalizedConfig.moduleSideEffects = config.moduleSideEffects;
	normalizedConfig.annotations = config.annotations ?? true;
	return normalizedConfig;
}

//#endregion
//#region src/utils/bindingify-output-options.ts
function bindingifyOutputOptions(outputOptions) {
	const { dir, format, exports: exports$1, hashCharacters, sourcemap, sourcemapIgnoreList, sourcemapPathTransform, name, assetFileNames, entryFileNames, chunkFileNames, cssEntryFileNames, cssChunkFileNames, banner, footer, intro, outro, esModule, globals, file } = outputOptions;
	return {
		dir,
		file: file == null ? undefined : file,
		format: bindingifyFormat(format),
		exports: exports$1,
		hashCharacters,
		sourcemap: bindingifySourcemap(sourcemap),
		sourcemapIgnoreList: bindingifySourcemapIgnoreList(sourcemapIgnoreList),
		sourcemapPathTransform,
		banner: bindingifyAddon(banner),
		footer: bindingifyAddon(footer),
		intro: bindingifyAddon(intro),
		outro: bindingifyAddon(outro),
		extend: outputOptions.extend,
		globals,
		esModule,
		name,
		assetFileNames,
		entryFileNames,
		chunkFileNames,
		cssEntryFileNames,
		cssChunkFileNames,
		plugins: [],
		minify: outputOptions.minify,
		externalLiveBindings: outputOptions.externalLiveBindings,
		inlineDynamicImports: outputOptions.inlineDynamicImports,
		advancedChunks: outputOptions.advancedChunks,
		polyfillRequire: outputOptions.polyfillRequire
	};
}
function bindingifyAddon(configAddon) {
	return async (chunk) => {
		if (typeof configAddon === "function") return configAddon(transformRenderedChunk(chunk));
		return configAddon || "";
	};
}
function bindingifyFormat(format) {
	switch (format) {
		case undefined:
		case "es":
		case "esm":
		case "module": return "es";
		case "cjs":
		case "commonjs": return "cjs";
		case "iife": return "iife";
		case "umd": return "umd";
		case "experimental-app": return "app";
		default: unimplemented(`output.format: ${format}`);
	}
}
function bindingifySourcemap(sourcemap) {
	switch (sourcemap) {
		case true: return "file";
		case "inline": return "inline";
		case false:
		case undefined: return undefined;
		case "hidden": return "hidden";
		default: throw new Error(`unknown sourcemap: ${sourcemap}`);
	}
}
function bindingifySourcemapIgnoreList(sourcemapIgnoreList) {
	return typeof sourcemapIgnoreList === "function" ? sourcemapIgnoreList : sourcemapIgnoreList === false ? () => false : (relativeSourcePath, _sourcemapPath) => relativeSourcePath.includes("node_modules");
}

//#endregion
//#region ../../node_modules/.pnpm/remeda@2.16.0/node_modules/remeda/dist/chunk-K26VP6CL.js
function u$1(t$1, n, a) {
	let o = (r) => t$1(r, ...n);
	return a === void 0 ? o : Object.assign(o, {
		lazy: a,
		lazyArgs: n
	});
}

//#endregion
//#region ../../node_modules/.pnpm/remeda@2.16.0/node_modules/remeda/dist/chunk-RAAYCPUM.js
function u(r, n, a) {
	let o = r.length - n.length;
	if (o === 0) return r(...n);
	if (o === 1) return u$1(r, n, a);
	throw new Error("Wrong number of arguments");
}

//#endregion
//#region ../../node_modules/.pnpm/remeda@2.16.0/node_modules/remeda/dist/chunk-NMJS7ULY.js
function t(...n) {
	return u(Object.keys, n);
}

//#endregion
//#region src/utils/plugin/index.ts
const isPluginHookName = function() {
	const PLUGIN_HOOK_NAMES_SET = new Set(ENUMERATED_PLUGIN_HOOK_NAMES);
	return function isPluginHookName$1(hookName) {
		return PLUGIN_HOOK_NAMES_SET.has(hookName);
	};
}();

//#endregion
//#region src/utils/compose-js-plugins.ts
const unsupportedHookName = [
	"augmentChunkHash",
	"generateBundle",
	"moduleParsed",
	"onLog",
	"options",
	"outputOptions",
	"renderError",
	"renderStart",
	"resolveDynamicImport",
	"writeBundle"
];
const unsupportedHooks = new Set(unsupportedHookName);
function isUnsupportedHooks(hookName) {
	return unsupportedHooks.has(hookName);
}
function createComposedPlugin(plugins) {
	const names = [];
	const batchedHooks = {};
	plugins.forEach((plugin, index) => {
		const pluginName = plugin.name || `Anonymous(index: ${index})`;
		names.push(pluginName);
		t(plugin).forEach((pluginProp) => {
			if (isUnsupportedHooks(pluginProp)) throw new Error(`Failed to compose js plugins. Plugin ${pluginName} has an unsupported hook: ${pluginProp}`);
			if (!isPluginHookName(pluginProp)) return;
			switch (pluginProp) {
				case "buildStart": {
					const handlers = batchedHooks.buildStart ?? [];
					batchedHooks.buildStart = handlers;
					if (plugin.buildStart) handlers.push([plugin.buildStart, plugin]);
					break;
				}
				case "load": {
					const handlers = batchedHooks.load ?? [];
					batchedHooks.load = handlers;
					if (plugin.load) handlers.push([plugin.load, plugin]);
					break;
				}
				case "transform": {
					const handlers = batchedHooks.transform ?? [];
					batchedHooks.transform = handlers;
					if (plugin.transform) handlers.push([plugin.transform, plugin]);
					break;
				}
				case "resolveId": {
					const handlers = batchedHooks.resolveId ?? [];
					batchedHooks.resolveId = handlers;
					if (plugin.resolveId) handlers.push([plugin.resolveId, plugin]);
					break;
				}
				case "buildEnd": {
					const handlers = batchedHooks.buildEnd ?? [];
					batchedHooks.buildEnd = handlers;
					if (plugin.buildEnd) handlers.push([plugin.buildEnd, plugin]);
					break;
				}
				case "renderChunk": {
					const handlers = batchedHooks.renderChunk ?? [];
					batchedHooks.renderChunk = handlers;
					if (plugin.renderChunk) handlers.push([plugin.renderChunk, plugin]);
					break;
				}
				case "banner":
				case "footer":
				case "intro":
				case "outro": {
					const hook = plugin[pluginProp];
					if (hook) (batchedHooks[pluginProp] ??= []).push([hook, plugin]);
					break;
				}
				case "closeBundle": {
					const handlers = batchedHooks.closeBundle ?? [];
					batchedHooks.closeBundle = handlers;
					if (plugin.closeBundle) handlers.push([plugin.closeBundle, plugin]);
					break;
				}
				case "watchChange": {
					const handlers = batchedHooks.watchChange ?? [];
					batchedHooks.watchChange = handlers;
					if (plugin.watchChange) handlers.push([plugin.watchChange, plugin]);
					break;
				}
				case "closeWatcher": {
					const handlers = batchedHooks.closeWatcher ?? [];
					batchedHooks.closeWatcher = handlers;
					if (plugin.closeWatcher) handlers.push([plugin.closeWatcher, plugin]);
					break;
				}
				default: {}
			}
		});
	});
	const composed = { name: `Composed(${names.join(", ")})` };
	const createFixedPluginResolveFnMap = new Map();
	function applyFixedPluginResolveFn(ctx, plugin) {
		const createFixedPluginResolveFn = createFixedPluginResolveFnMap.get(plugin);
		if (createFixedPluginResolveFn) ctx.resolve = createFixedPluginResolveFn(ctx, ctx.resolve.bind(ctx));
		return ctx;
	}
	if (batchedHooks.resolveId) {
		const batchedHandlers = batchedHooks.resolveId;
		const handlerSymbols = batchedHandlers.map(([_handler, plugin]) => Symbol(plugin.name ?? `Anonymous`));
		for (let handlerIdx = 0; handlerIdx < batchedHandlers.length; handlerIdx++) {
			const [_handler, plugin] = batchedHandlers[handlerIdx];
			const handlerSymbol = handlerSymbols[handlerIdx];
			const createFixedPluginResolveFn = (ctx, resolve) => {
				return (source, importer, rawContextResolveOptions) => {
					const contextResolveOptions = rawContextResolveOptions ?? {};
					if (contextResolveOptions.skipSelf) {
						contextResolveOptions[SYMBOL_FOR_RESOLVE_CALLER_THAT_SKIP_SELF] = handlerSymbol;
						contextResolveOptions.skipSelf = false;
					}
					return resolve(source, importer, contextResolveOptions);
				};
			};
			createFixedPluginResolveFnMap.set(plugin, createFixedPluginResolveFn);
		}
		composed.resolveId = async function(source, importer, rawHookResolveIdOptions) {
			const hookResolveIdOptions = rawHookResolveIdOptions;
			const symbolForCallerThatSkipSelf = hookResolveIdOptions?.[SYMBOL_FOR_RESOLVE_CALLER_THAT_SKIP_SELF];
			for (let handlerIdx = 0; handlerIdx < batchedHandlers.length; handlerIdx++) {
				const [handler, plugin] = batchedHandlers[handlerIdx];
				const handlerSymbol = handlerSymbols[handlerIdx];
				if (symbolForCallerThatSkipSelf === handlerSymbol) continue;
				const { handler: handlerFn } = normalizeHook(handler);
				const result = await handlerFn.call(applyFixedPluginResolveFn(this, plugin), source, importer, rawHookResolveIdOptions);
				if (!isNullish(result)) return result;
			}
		};
	}
	t(batchedHooks).forEach((hookName) => {
		switch (hookName) {
			case "resolveId": break;
			case "buildStart": {
				if (batchedHooks.buildStart) {
					const batchedHandlers = batchedHooks.buildStart;
					composed.buildStart = async function(options) {
						await Promise.all(batchedHandlers.map(([handler, plugin]) => {
							const { handler: handlerFn } = normalizeHook(handler);
							return handlerFn.call(applyFixedPluginResolveFn(this, plugin), options);
						}));
					};
				}
				break;
			}
			case "load": {
				if (batchedHooks.load) {
					const batchedHandlers = batchedHooks.load;
					composed.load = async function(id) {
						for (const [handler, plugin] of batchedHandlers) {
							const { handler: handlerFn } = normalizeHook(handler);
							const result = await handlerFn.call(applyFixedPluginResolveFn(this, plugin), id);
							if (!isNullish(result)) return result;
						}
					};
				}
				break;
			}
			case "transform": {
				if (batchedHooks.transform) {
					const batchedHandlers = batchedHooks.transform;
					composed.transform = async function(initialCode, id, moduleType) {
						let code = initialCode;
						let moduleSideEffects = undefined;
						function updateOutput(newCode, newModuleSideEffects) {
							code = newCode;
							moduleSideEffects = newModuleSideEffects ?? undefined;
						}
						for (const [handler, plugin] of batchedHandlers) {
							const { handler: handlerFn } = normalizeHook(handler);
							this.getCombinedSourcemap = () => {
								throw new Error(`The getCombinedSourcemap is not implement in transform hook at composedJsPlugins`);
							};
							const result = await handlerFn.call(applyFixedPluginResolveFn(this, plugin), code, id, moduleType);
							if (!isNullish(result)) {
								if (typeof result === "string") updateOutput(result);
else if (result.code) updateOutput(result.code, result.moduleSideEffects);
							}
						}
						return {
							code,
							moduleSideEffects
						};
					};
				}
				break;
			}
			case "buildEnd": {
				if (batchedHooks.buildEnd) {
					const batchedHandlers = batchedHooks.buildEnd;
					composed.buildEnd = async function(err) {
						await Promise.all(batchedHandlers.map(([handler, plugin]) => {
							const { handler: handlerFn } = normalizeHook(handler);
							return handlerFn.call(applyFixedPluginResolveFn(this, plugin), err);
						}));
					};
				}
				break;
			}
			case "renderChunk": {
				if (batchedHooks.renderChunk) {
					const batchedHandlers = batchedHooks.renderChunk;
					composed.renderChunk = async function(code, chunk, options) {
						for (const [handler, plugin] of batchedHandlers) {
							const { handler: handlerFn } = normalizeHook(handler);
							const result = await handlerFn.call(applyFixedPluginResolveFn(this, plugin), code, chunk, options);
							if (!isNullish(result)) return result;
						}
					};
				}
				break;
			}
			case "banner":
			case "footer":
			case "intro":
			case "outro": {
				const hooks = batchedHooks[hookName];
				if (hooks?.length) composed[hookName] = async function(chunk) {
					const ret = [];
					for (const [hook, plugin] of hooks) {
						const { handler } = normalizeHook(hook);
						ret.push(typeof handler === "string" ? handler : await handler.call(applyFixedPluginResolveFn(this, plugin), chunk));
					}
					return ret.join("\n");
				};
				break;
			}
			case "closeBundle": {
				if (batchedHooks.closeBundle) {
					const batchedHandlers = batchedHooks.closeBundle;
					composed.closeBundle = async function() {
						await Promise.all(batchedHandlers.map(([handler, plugin]) => {
							const { handler: handlerFn } = normalizeHook(handler);
							return handlerFn.call(applyFixedPluginResolveFn(this, plugin));
						}));
					};
				}
				break;
			}
			case "watchChange": {
				if (batchedHooks.watchChange) {
					const batchedHandlers = batchedHooks.watchChange;
					composed.watchChange = async function(id, event) {
						await Promise.all(batchedHandlers.map(([handler, plugin]) => {
							const { handler: handlerFn } = normalizeHook(handler);
							return handlerFn.call(applyFixedPluginResolveFn(this, plugin), id, event);
						}));
					};
				}
				break;
			}
			case "closeWatcher": {
				if (batchedHooks.closeWatcher) {
					const batchedHandlers = batchedHooks.closeWatcher;
					composed.closeWatcher = async function() {
						await Promise.all(batchedHandlers.map(([handler, plugin]) => {
							const { handler: handlerFn } = normalizeHook(handler);
							return handlerFn.call(applyFixedPluginResolveFn(this, plugin));
						}));
					};
				}
				break;
			}
			default: {}
		}
	});
	return composed;
}
function isComposablePlugin(plugin) {
	if (plugin instanceof BuiltinPlugin) return false;
	if ("_parallel" in plugin) return false;
	const hasNotComposablePattern = t(plugin).some((hookName) => {
		if (!isPluginHookName(hookName)) return false;
		const OK_TO_COMPOSE = false;
		if (isUnsupportedHooks(hookName)) return !OK_TO_COMPOSE;
		if (plugin[hookName]) {
			const { meta } = normalizeHook(plugin[hookName]);
			if (meta.order === "pre" || meta.order === "post") return !OK_TO_COMPOSE;
		}
		return OK_TO_COMPOSE;
	});
	if (hasNotComposablePattern) return false;
	return true;
}
function composeJsPlugins(plugins) {
	const newPlugins = [];
	const toBeComposed = [];
	plugins.forEach((plugin) => {
		if (isComposablePlugin(plugin)) toBeComposed.push(plugin);
else {
			if (toBeComposed.length > 0) {
				if (toBeComposed.length > 1) newPlugins.push(createComposedPlugin(toBeComposed));
else newPlugins.push(toBeComposed[0]);
				toBeComposed.length = 0;
			}
			newPlugins.push(plugin);
		}
	});
	if (toBeComposed.length > 0) {
		if (toBeComposed.length > 1) newPlugins.push(createComposedPlugin(toBeComposed));
else newPlugins.push(toBeComposed[0]);
		toBeComposed.length = 0;
	}
	return newPlugins;
}

//#endregion
//#region src/utils/initialize-parallel-plugins.ts
var import_binding$2 = require_chunk.__toESM(require_binding());
async function initializeParallelPlugins(plugins) {
	const pluginInfos = [];
	for (const [index, plugin] of plugins.entries()) if ("_parallel" in plugin) {
		const { fileUrl, options } = plugin._parallel;
		pluginInfos.push({
			index,
			fileUrl,
			options
		});
	}
	if (pluginInfos.length <= 0) return undefined;
	const count = Math.min((0, node_os.availableParallelism)(), 8);
	const parallelJsPluginRegistry = new import_binding$2.ParallelJsPluginRegistry(count);
	const registryId = parallelJsPluginRegistry.id;
	const workers = await initializeWorkers(registryId, count, pluginInfos);
	const stopWorkers = async () => {
		await Promise.all(workers.map((worker) => worker.terminate()));
	};
	return {
		registry: parallelJsPluginRegistry,
		stopWorkers
	};
}
function initializeWorkers(registryId, count, pluginInfos) {
	return Promise.all(Array.from({ length: count }, (_, i) => initializeWorker(registryId, pluginInfos, i)));
}
async function initializeWorker(registryId, pluginInfos, threadNumber) {
	const urlString = undefined("#parallel-plugin-worker");
	const workerData = {
		registryId,
		pluginInfos,
		threadNumber
	};
	let worker;
	try {
		worker = new node_worker_threads.Worker(new URL(urlString), { workerData });
		worker.unref();
		await new Promise((resolve, reject) => {
			worker.once("message", async (message) => {
				if (message.type === "error") reject(message.error);
else resolve();
			});
		});
		return worker;
	} catch (e) {
		worker?.terminate();
		throw e;
	}
}

//#endregion
//#region src/utils/create-bundler-option.ts
async function createBundlerOptions(inputOptions, outputOptions) {
	const pluginDriver = new PluginDriver();
	inputOptions = await pluginDriver.callOptionsHook(inputOptions);
	if (inputOptions.treeshake !== undefined) TreeshakingOptionsSchema.parse(inputOptions.treeshake);
	const inputPlugins = await normalizePluginOption(inputOptions.plugins);
	const outputPlugins = await normalizePluginOption(outputOptions.plugins);
	const logLevel = inputOptions.logLevel || LOG_LEVEL_INFO;
	const onLog = getLogger(getObjectPlugins(inputPlugins), getOnLog(inputOptions, logLevel), logLevel);
	outputOptions = pluginDriver.callOutputOptionsHook([...inputPlugins, ...outputPlugins], outputOptions);
	if (outputOptions.minify === true) onLog(LOG_LEVEL_WARN, logMinifyWarning());
	let plugins = [...normalizePlugins(inputPlugins, ANONYMOUS_PLUGIN_PREFIX), ...checkOutputPluginOption(normalizePlugins(await normalizePluginOption(outputOptions.plugins), ANONYMOUS_OUTPUT_PLUGIN_PREFIX), onLog)];
	if (inputOptions.experimental?.enableComposingJsPlugins ?? false) plugins = composeJsPlugins(plugins);
	const parallelPluginInitResult = await initializeParallelPlugins(plugins);
	try {
		const bindingInputOptions = bindingifyInputOptions(plugins, inputOptions, outputOptions, onLog, logLevel);
		const bindingOutputOptions = bindingifyOutputOptions(outputOptions);
		return {
			bundlerOptions: {
				inputOptions: bindingInputOptions,
				outputOptions: bindingOutputOptions,
				parallelPluginsRegistry: parallelPluginInitResult?.registry
			},
			inputOptions,
			onLog,
			stopWorkers: parallelPluginInitResult?.stopWorkers
		};
	} catch (e) {
		await parallelPluginInitResult?.stopWorkers();
		throw e;
	}
}

//#endregion
//#region src/utils/create-bundler.ts
var import_binding$1 = require_chunk.__toESM(require_binding());
async function createBundler(inputOptions, outputOptions) {
	const option = await createBundlerOptions(inputOptions, outputOptions);
	try {
		return {
			bundler: new import_binding$1.Bundler(option.bundlerOptions),
			stopWorkers: option.stopWorkers
		};
	} catch (e) {
		await option.stopWorkers?.();
		throw e;
	}
}

//#endregion
//#region src/api/rolldown/rolldown-build.ts
Symbol.asyncDispose ??= Symbol("Symbol.asyncDispose");
var RolldownBuild = class {
	#inputOptions;
	#bundler;
	constructor(inputOptions) {
		this.#inputOptions = inputOptions;
	}
	get closed() {
		return this.#bundler ? this.#bundler.bundler.closed : false;
	}
	async #getBundlerWithStopWorker(outputOptions) {
		if (this.#bundler) this.#bundler.stopWorkers?.();
		return this.#bundler = await createBundler(this.#inputOptions, outputOptions);
	}
	async generate(outputOptions = {}) {
		const { bundler } = await this.#getBundlerWithStopWorker(outputOptions);
		const output = await bundler.generate();
		return transformToRollupOutput(output);
	}
	async write(outputOptions = {}) {
		const { bundler } = await this.#getBundlerWithStopWorker(outputOptions);
		const output = await bundler.write();
		return transformToRollupOutput(output);
	}
	async close() {
		const { bundler, stopWorkers } = await this.#getBundlerWithStopWorker({});
		await stopWorkers?.();
		await bundler.close();
	}
	async [Symbol.asyncDispose]() {
		await this.close();
	}
};

//#endregion
//#region src/api/rolldown/index.ts
const rolldown = async (input) => {
	return new RolldownBuild(input);
};

//#endregion
//#region src/api/watch/watch-emitter.ts
var WatcherEmitter = class {
	listeners = new Map();
	timer;
	constructor() {
		this.timer = setInterval(
			() => {},
			1e9
			/* Low power usage */
);
	}
	on(event, listener) {
		const listeners = this.listeners.get(event);
		if (listeners) listeners.push(listener);
else this.listeners.set(event, [listener]);
		return this;
	}
	async onEvent(event) {
		const listeners = this.listeners.get(event.eventKind());
		if (listeners) switch (event.eventKind()) {
			case "close":
			case "restart":
				for (const listener of listeners) await listener();
				break;
			case "event":
				for (const listener of listeners) {
					const code = event.bundleEventKind();
					switch (code) {
						case "BUNDLE_END":
							const { duration, output } = event.bundleEndData();
							await listener({
								code: "BUNDLE_END",
								duration,
								output: [output]
							});
							break;
						case "ERROR":
							const errors = event.errors();
							await listener({
								code: "ERROR",
								error: normalizeErrors(errors)
							});
							break;
						default:
							await listener({ code });
							break;
					}
				}
				break;
			case "change":
				for (const listener of listeners) {
					const { path: path$2, kind } = event.watchChangeData();
					await listener(path$2, { event: kind });
				}
				break;
			default: throw new Error(`Unknown event: ${event}`);
		}
	}
	async close() {
		clearInterval(this.timer);
	}
};

//#endregion
//#region src/api/watch/watcher.ts
var import_binding = require_chunk.__toESM(require_binding());
var Watcher = class {
	closed;
	inner;
	emitter;
	stopWorkers;
	constructor(emitter, inner, stopWorkers) {
		this.closed = false;
		this.inner = inner;
		this.emitter = emitter;
		const originClose = emitter.close.bind(emitter);
		emitter.close = async () => {
			await this.close();
			originClose();
		};
		this.stopWorkers = stopWorkers;
	}
	async close() {
		if (this.closed) return;
		this.closed = true;
		for (const stop of this.stopWorkers) await stop?.();
		await this.inner.close();
	}
	start() {
		process.nextTick(() => this.inner.start(this.emitter.onEvent.bind(this.emitter)));
	}
};
async function createWatcher(emitter, input) {
	const options = arraify(input);
	const bundlerOptions = await Promise.all(options.map((option) => arraify(option.output || {}).map((output) => createBundlerOptions(option, output))).flat());
	const notifyOptions = getValidNotifyOption(bundlerOptions);
	const bindingWatcher = new import_binding.BindingWatcher(bundlerOptions.map((option) => option.bundlerOptions), notifyOptions);
	const watcher = new Watcher(emitter, bindingWatcher, bundlerOptions.map((option) => option.stopWorkers));
	watcher.start();
}
function getValidNotifyOption(bundlerOptions) {
	let result;
	for (const option of bundlerOptions) if (option.inputOptions.watch) {
		const notifyOption = option.inputOptions.watch.notify;
		if (notifyOption) if (result) {
			option.onLog(LOG_LEVEL_WARN, logMultiplyNotifyOption());
			return result;
		} else result = notifyOption;
	}
}

//#endregion
//#region src/api/watch/index.ts
const watch = (input) => {
	const emitter = new WatcherEmitter();
	createWatcher(emitter, input);
	return emitter;
};

//#endregion
//#region package.json
var version = "1.0.0-beta.1";
var description = "Fast JavaScript/TypeScript bundler in Rust with Rollup-compatible API.";

//#endregion
//#region src/api/build.ts
async function build(options) {
	if (Array.isArray(options)) return Promise.all(options.map((opts) => build(opts)));
else {
		const { output, write = true,...inputOptions } = options;
		const build$1 = await rolldown(inputOptions);
		try {
			if (write) return await build$1.write(output);
else return await build$1.generate(output);
		} finally {
			await build$1.close();
		}
	}
}

//#endregion
//#region src/index.ts
const VERSION = version;

//#endregion
Object.defineProperty(exports, 'BuiltinPlugin', {
  enumerable: true,
  get: function () {
    return BuiltinPlugin;
  }
});
Object.defineProperty(exports, 'LogLevelOptionSchema', {
  enumerable: true,
  get: function () {
    return LogLevelOptionSchema;
  }
});
Object.defineProperty(exports, 'LogLevelSchema', {
  enumerable: true,
  get: function () {
    return LogLevelSchema;
  }
});
Object.defineProperty(exports, 'LogLevelWithErrorSchema', {
  enumerable: true,
  get: function () {
    return LogLevelWithErrorSchema;
  }
});
Object.defineProperty(exports, 'PluginContextData', {
  enumerable: true,
  get: function () {
    return PluginContextData;
  }
});
Object.defineProperty(exports, 'RollupLogSchema', {
  enumerable: true,
  get: function () {
    return RollupLogSchema;
  }
});
Object.defineProperty(exports, 'RollupLogWithStringSchema', {
  enumerable: true,
  get: function () {
    return RollupLogWithStringSchema;
  }
});
Object.defineProperty(exports, 'TreeshakingOptionsSchema', {
  enumerable: true,
  get: function () {
    return TreeshakingOptionsSchema;
  }
});
Object.defineProperty(exports, 'VERSION', {
  enumerable: true,
  get: function () {
    return VERSION;
  }
});
Object.defineProperty(exports, 'arraify', {
  enumerable: true,
  get: function () {
    return arraify;
  }
});
Object.defineProperty(exports, 'bindingifyPlugin', {
  enumerable: true,
  get: function () {
    return bindingifyPlugin;
  }
});
Object.defineProperty(exports, 'build', {
  enumerable: true,
  get: function () {
    return build;
  }
});
Object.defineProperty(exports, 'buildImportAnalysisPlugin', {
  enumerable: true,
  get: function () {
    return buildImportAnalysisPlugin;
  }
});
Object.defineProperty(exports, 'composeJsPlugins', {
  enumerable: true,
  get: function () {
    return composeJsPlugins;
  }
});
Object.defineProperty(exports, 'createBundler', {
  enumerable: true,
  get: function () {
    return createBundler;
  }
});
Object.defineProperty(exports, 'defineConfig', {
  enumerable: true,
  get: function () {
    return defineConfig;
  }
});
Object.defineProperty(exports, 'description', {
  enumerable: true,
  get: function () {
    return description;
  }
});
Object.defineProperty(exports, 'dynamicImportVarsPlugin', {
  enumerable: true,
  get: function () {
    return dynamicImportVarsPlugin;
  }
});
Object.defineProperty(exports, 'handleOutputErrors', {
  enumerable: true,
  get: function () {
    return handleOutputErrors;
  }
});
Object.defineProperty(exports, 'importGlobPlugin', {
  enumerable: true,
  get: function () {
    return importGlobPlugin;
  }
});
Object.defineProperty(exports, 'jsonPlugin', {
  enumerable: true,
  get: function () {
    return jsonPlugin;
  }
});
Object.defineProperty(exports, 'loadFallbackPlugin', {
  enumerable: true,
  get: function () {
    return loadFallbackPlugin;
  }
});
Object.defineProperty(exports, 'manifestPlugin', {
  enumerable: true,
  get: function () {
    return manifestPlugin;
  }
});
Object.defineProperty(exports, 'modulePreloadPolyfillPlugin', {
  enumerable: true,
  get: function () {
    return modulePreloadPolyfillPlugin;
  }
});
Object.defineProperty(exports, 'normalizedStringOrRegex', {
  enumerable: true,
  get: function () {
    return normalizedStringOrRegex;
  }
});
Object.defineProperty(exports, 'require_binding', {
  enumerable: true,
  get: function () {
    return require_binding;
  }
});
Object.defineProperty(exports, 'rolldown', {
  enumerable: true,
  get: function () {
    return rolldown;
  }
});
Object.defineProperty(exports, 'version', {
  enumerable: true,
  get: function () {
    return version;
  }
});
Object.defineProperty(exports, 'viteResolvePlugin', {
  enumerable: true,
  get: function () {
    return viteResolvePlugin;
  }
});
Object.defineProperty(exports, 'wasmFallbackPlugin', {
  enumerable: true,
  get: function () {
    return wasmFallbackPlugin;
  }
});
Object.defineProperty(exports, 'wasmHelperPlugin', {
  enumerable: true,
  get: function () {
    return wasmHelperPlugin;
  }
});
Object.defineProperty(exports, 'watch', {
  enumerable: true,
  get: function () {
    return watch;
  }
});